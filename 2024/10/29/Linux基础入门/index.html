<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux基础入门 | Leo's blog</title><meta name="author" content="Leo"><meta name="copyright" content="Leo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux基础入门">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux基础入门">
<meta property="og:url" content="http://example.com/2024/10/29/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="Leo&#39;s blog">
<meta property="og:description" content="Linux基础入门">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.jpg">
<meta property="article:published_time" content="2024-10-29T08:27:40.000Z">
<meta property="article:modified_time" content="2024-10-29T10:36:30.636Z">
<meta property="article:author" content="Leo">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.jpg"><link rel="shortcut icon" href="/img/leologo.png"><link rel="canonical" href="http://example.com/2024/10/29/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux基础入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-29 18:36:30'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/websitelogo.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Leo's blog"><img class="site-icon" src="/img/titlelogo.jpg"/><span class="site-name">Leo's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux基础入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-29T08:27:40.000Z" title="发表于 2024-10-29 16:27:40">2024-10-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-29T10:36:30.636Z" title="更新于 2024-10-29 18:36:30">2024-10-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux基础入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-Linux系统简介"><a href="#1-Linux系统简介" class="headerlink" title="1. Linux系统简介"></a>1. Linux系统简介</h1><h2 id="1-1-Linux历史简介"><a href="#1-1-Linux历史简介" class="headerlink" title="1.1. Linux历史简介"></a>1.1. Linux历史简介</h2><ol>
<li><strong>批处理操作系统</strong>：始于20世纪50年代，不需要用户交互，从文件或穿孔卡片读取数据，然后输出到文件或打印机。</li>
<li><strong>分时操作系统</strong>：20世纪60年代初开始流行，允许多个用户同时从不同终端操作主机，对批处理操作系统构成挑战。</li>
<li><strong>Multics项目</strong>：一个创新的分时操作系统项目，但由于成本超支和市场表现不佳，最终失败。</li>
<li><strong>UNIX的诞生</strong>：Multics项目失败后，贝尔实验室的团队开发了UNIX，最初免费发布，后来实现了TCP/IP协议栈，成为早期工作站的流行操作系统。</li>
<li><strong>UNIX的商业化</strong>：1990年，UNIX在服务器市场成为主流，但价格昂贵。MINIX作为廉价替代品出现，用于教学。</li>
<li><strong>Linux的诞生</strong>：1991年，Linus Torvalds在接触UNIX后，希望开发一个类似但更高性能的操作系统。他从MINIX开始，最终开发出了Linux。</li>
<li><strong>Linux的发展</strong>：Linux最初版本吸引了黑客社区的关注，迅速增加了新特性。Linux内核负责多任务和硬件管理，Linus利用自由软件减少了开发工作量。</li>
<li><strong>GNU项目</strong>：1984年启动，旨在开发一个免费的类UNIX操作系统。Linux的成功部分归功于GNU项目的贡献。</li>
<li><strong>Linux的成熟</strong>：1992-1993年，Linux内核具备了挑战UNIX的所有特性，包括TCP/IP网络和图形界面。Linux开始吸引行业关注。</li>
<li><strong>Linux内核1.0发布</strong>：1994年3月发布，标志着Linux的稳定发展。</li>
<li><strong>Linux的重要里程碑</strong>：</li>
</ol>
<ul>
<li>1965年Multics项目启动，1969年失败。</li>
<li>1969年Ken Thompson开发了UNIX原型。</li>
<li>1973年C语言发明，UNIX内核用C语言重写。</li>
<li>1977年BSD（Berkeley Software Distribution）发布。</li>
<li>1979年UNIX System V发布。</li>
<li>1984年MINIX和GNU项目启动。</li>
<li>1985年GPL（General Public License）发布。</li>
<li>1988年XFree86组织成立。</li>
<li>1991年Linux内核开发。</li>
<li>1994年Linux-v1.0发布。</li>
<li>1996年Linux-v2.0发布，确定吉祥物为企鹅。</li>
</ul>
<h2 id="1-2-Linux重要人物"><a href="#1-2-Linux重要人物" class="headerlink" title="1.2. Linux重要人物"></a>1.2. Linux重要人物</h2><ol>
<li>Ken Thompson：C 语言之父和 UNIX 之父</li>
</ol>
<p><img src="/img/Ken.png" alt="img"></p>
<ol>
<li>Dennis Ritchie：C 语言之父和 UNIX 之父</li>
</ol>
<p><img src="/img/Den.jpg" alt="img"></p>
<h2 id="1-3-Linux与Windows区别"><a href="#1-3-Linux与Windows区别" class="headerlink" title="1.3. Linux与Windows区别"></a>1.3. Linux与Windows区别</h2><p>这段文字对比了Windows和Linux操作系统的主要特点：</p>
<ol>
<li><strong>成本</strong>：</li>
</ol>
<ul>
<li>Windows 10通常需要购买。</li>
<li>Linux通常是免费或低成本。</li>
</ul>
<ol>
<li><strong>软件和支持</strong>：</li>
</ol>
<ul>
<li>Windows有大量软件，但多为付费，由微软提供支持。</li>
<li>Linux主要是开源软件，用户可以自由修改，由社区支持，但可能缺乏资金支持。</li>
</ul>
<ol>
<li><strong>安全性</strong>：</li>
</ol>
<ul>
<li>Windows需要频繁更新，但仍然可能受到攻击。</li>
<li>Linux通常被认为更安全，不需要杀毒软件。</li>
</ul>
<ol>
<li><strong>用户体验</strong>：</li>
</ol>
<ul>
<li>Windows界面友好，易于上手。</li>
<li>Linux有图形和命令行界面，学习曲线较陡，但效率高。</li>
</ul>
<ol>
<li><strong>可定制性</strong>：</li>
</ol>
<ul>
<li>Windows过去较为封闭，可定制性较差。</li>
<li>Linux高度可定制。</li>
</ul>
<ol>
<li><strong>应用范围</strong>：</li>
</ol>
<ul>
<li>Linux广泛应用于服务器和互联网服务。</li>
</ul>
<ol>
<li><strong>Windows缺乏</strong>：</li>
</ol>
<ul>
<li>稳定性、安全性、多用户支持、资源占用少、可移植性、多种界面。</li>
</ul>
<ol>
<li><strong>Linux缺乏</strong>：</li>
</ol>
<ul>
<li>特定厂商支持、游戏和娱乐软件、专业软件。</li>
</ul>
<h2 id="1-4-Linux学习路径"><a href="#1-4-Linux学习路径" class="headerlink" title="1.4. Linux学习路径"></a>1.4. Linux学习路径</h2><p><img src="/img/Linux学习路径.png" alt="img"></p>
<ul>
<li><strong>Linux发行版及其选择</strong></li>
</ul>
<ol>
<li><strong>桌面用户</strong>：</li>
</ol>
<ul>
<li><strong>简单易用</strong>：选择Ubuntu、Kubuntu或Xubuntu，它们提供不同的桌面环境。</li>
<li><strong>高级定制</strong>：选择Gentoo，适合想要深入定制系统性能的用户。</li>
</ul>
<ol>
<li><strong>服务器用户</strong>：</li>
</ol>
<ul>
<li><strong>稳定易管理</strong>：选择CentOS，适合需要稳定服务且不想深入配置的用户。</li>
<li><strong>超级稳定</strong>：选择FreeBSD，适合需要极高稳定性的用户。</li>
<li><strong>高级定制</strong>：选择Gentoo，适合想要深入了解Linux并进行大量自定义的用户。</li>
</ul>
<h1 id="2-基本概念及操作"><a href="#2-基本概念及操作" class="headerlink" title="2. 基本概念及操作"></a>2. 基本概念及操作</h1><h2 id="2-1-终端"><a href="#2-1-终端" class="headerlink" title="2.1. 终端"></a>2.1. 终端</h2><p>在物理机系统使用<code>Ctrl+Alt+F1+F6</code>进行切换</p>
<h2 id="2-2-shell"><a href="#2-2-shell" class="headerlink" title="2.2. shell"></a>2.2. shell</h2><ol>
<li><strong>Shell的定义</strong>：</li>
</ol>
<ul>
<li>Shell是命令解析器，提供用户与操作系统交互的界面。</li>
</ul>
<ol>
<li><strong>Shell与内核的关系</strong>：</li>
</ol>
<ul>
<li>Shell基于内核提供服务，隐藏操作系统底层细节。</li>
</ul>
<ol>
<li><strong>Shell与图形用户界面</strong>：</li>
</ol>
<ul>
<li>图形用户界面（<code>GNOME</code>、<code>KDE</code>）也被称为“图形Shell”。</li>
</ul>
<ol>
<li><strong>Shell与Windows命令行</strong>：</li>
</ol>
<ul>
<li><code>Windows</code>命令行功能有限，<code>UNIX/Linux</code>的<code>Shell</code>提供更强大的控制语句。</li>
</ul>
<ol>
<li><strong>常见的Shell类型</strong>：</li>
</ol>
<ul>
<li><code>UNIX/Linux</code>中常见的Shell包括<code>bash</code>、<code>zsh</code>、<code>ksh</code>、<code>csh</code>。</li>
</ul>
<ol>
<li><strong>Shell的重要性</strong>：</li>
</ol>
<ul>
<li>Shell是控制系统启动、X11启动和其他实用工具的脚本解释程序。</li>
</ul>
<h2 id="2-3-常用快捷键"><a href="#2-3-常用快捷键" class="headerlink" title="2.3. 常用快捷键"></a>2.3. 常用快捷键</h2><ul>
<li><code>Tab</code>：补全、帮助提示。</li>
</ul>
<p>在忘记某个命令的全称时可以只输入它的开头的一部分，然后按下<code>Tab</code>获取帮助提示。</p>
<ul>
<li><code>Ctrl+c</code>：强制终止</li>
<li><code>↑</code>：恢复上一个命令</li>
<li><p><strong>Shell通配符</strong></p>
</li>
<li><p><code>*</code>：模糊匹配（如文件名称)【<strong>多个字符</strong>】</p>
</li>
<li><code>?</code>：模糊匹配【<strong>单个字符</strong>】</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td>匹配 0 或多个字符</td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配任意一个字符</td>
</tr>
<tr>
<td><code>[list]</code></td>
<td>匹配 list 中的任意单一字符</td>
</tr>
<tr>
<td><code>[^list]</code></td>
<td>匹配 除 list 中的任意单一字符以外的字符</td>
</tr>
<tr>
<td><code>[c1-c2]</code></td>
<td>匹配 c1-c2 中的任意单一字符 如：[0-9][a-z]</td>
</tr>
<tr>
<td><code>&#123;string1,string2,...&#125;</code></td>
<td>匹配 string1 或 string2 (或更多)其一字符串</td>
</tr>
<tr>
<td><code>&#123;c1..c2&#125;</code></td>
<td>匹配 c1-c2 中全部字符 如{1..10}</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>一次性创建多个文件：<code>touch love_&#123;1..10&#125;_shiyanlou.txt</code></li>
</ul>
<ul>
<li><code>man</code>：<code>man+&lt;命令&gt;</code>查看某个命令的说明和使用方式【按<code>q</code>退出】</li>
<li><code>--help</code>：在某个命令后面加上<code>--help</code>可以快速查看命令的作用</li>
<li><code>pwd</code>：查看当前所在的目录</li>
</ul>
<h2 id="2-4-输出图形命令"><a href="#2-4-输出图形命令" class="headerlink" title="2.4. 输出图形命令"></a>2.4. 输出图形命令</h2><ul>
<li><p>使用<code>banner</code>命令：输出图形字符</p>
</li>
<li><p>安装：<code>sudo apt-get update</code> <code>sudo apt-get install sysvbanner</code></p>
</li>
</ul>
<p>使用：输入<code>banner+想要输出的字符</code>，即可打印出来，示例：</p>
<p><img src="/img/banner.png" alt="img"></p>
<h1 id="3-用户及文件权限管理"><a href="#3-用户及文件权限管理" class="headerlink" title="3. 用户及文件权限管理"></a>3. 用户及文件权限管理</h1><h2 id="3-1-查看用户"><a href="#3-1-查看用户" class="headerlink" title="3.1. 查看用户"></a>3.1. 查看用户</h2><ul>
<li>使用<code>whoami</code>命令:查看当前登录的用户的用户名</li>
</ul>
<p>在登录式Shell中，<code>who am i</code>命令会输出当前用户的信息。但在<strong>非登录式</strong><code>**Shell**</code>中，可能不会输出任何内容，因为<strong>非登录式Shell</strong>没有与who命令的stdin相关联的用户信息。</p>
<ul>
<li><strong>登录式Shell</strong>：用户登录系统时启动的第一个交互式Shell，与用户的登录会话直接相关。</li>
<li><p><strong>非登录式Shell</strong>：在登录式Shell之后启动的Shell，通常用于执行特定的命令或脚本。</p>
</li>
<li><p><strong>判断Shell类型</strong>：可以通过执行echo $0命令来判断当前的Shell类型。如果输出是Shell的路径（如/bin/bash），则为非登录式Shell；如果输出是Shell的名称前带负号（如-bash），则为登录式Shell。</p>
</li>
<li><p><code>who</code>命令其他常用参数：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-a</code></td>
<td>打印能打印的全部</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>打印死掉的进程</td>
</tr>
<tr>
<td><code>-m</code></td>
<td>同<code>am i</code>，<code>mom likes</code></td>
</tr>
<tr>
<td><code>**-q**</code></td>
<td>打印当前登录用户数及用户名</td>
</tr>
<tr>
<td><code>-u</code></td>
<td>打印当前登录用户登录信息</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>打印运行等级</td>
</tr>
</tbody>
</table>
</div>
<h2 id="3-2-创建用户"><a href="#3-2-创建用户" class="headerlink" title="3.2. 创建用户"></a>3.2. 创建用户</h2><ul>
<li><p><strong>使用</strong><code>**sudo adduser** leo</code><strong>命令：</strong>创建一个名为leo的用户账号。</p>
</li>
<li><p>通常会为新用户在<code>/home</code>下创建一个对应主目录，比如<code>/home/lilei</code>，用于存储个人文件和设置</p>
</li>
<li><p>使用<code>su -l leo</code>命令<strong>：切换到用户leo</strong></p>
</li>
<li><p>su就是“<code>switch user</code>的缩写”，<code>-l</code>表示以目标用户的登录环境进行切换</p>
</li>
<li><p>使用<code>Ctrl+D</code>命令：退出当前用户</p>
</li>
</ul>
<h2 id="3-3-用户组"><a href="#3-3-用户组" class="headerlink" title="3.3. 用户组"></a>3.3. 用户组</h2><p>  在Linux中，每个用户都有一个归属（用户组），用户组可以理解为一组用户的集合，当然一个用户是可以属于多个用户组的。</p>
<ul>
<li>查看自己所在的用户组：</li>
</ul>
<ol>
<li>法一：使用<code>groups+用户名</code>命令</li>
<li>法二：使用<code>cat /etc/group | sort</code>命令来查看<code>/ect/group</code>文件</li>
</ol>
<ul>
<li><p>“<code>/etc/group</code>” 是一个系统文件，它存储了系统中的用户组信息。这个文件中的每一行代表一个用户组，包含组名、组密码、GID（组 ID）以及该组的成员列表等信息,</p>
</li>
<li><p>显示格式为：<code>**group_name:password:GID:user_list**</code></p>
</li>
<li><p>“|” 是管道符号，它将前一个命令的输出作为后一个命令的输入。</p>
</li>
<li><p>“sort” 是一个用于对文本进行排序的命令。它可以按照字母顺序、数字顺序等对输入的文本进行排序。</p>
</li>
<li><p>使用 <code>grep</code> 命令过滤掉一些你不想看到的结果：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/group | *grep* -E &quot;shiyanlou&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>将其他用户加入sudo用户组：</strong></li>
</ul>
<p>默认情况下新建的用户lilei不具有root权限，也不在sudo用户组</p>
<p>这里在切换到新用户lilei后，以超级用户的权限运行 “ls” 命令，列出当前目录下的文件和目录信息，但显示<code>lilei不在sudoers文件中。此事将被报告。</code></p>
<p><img src="/img/加入用户组.png" alt="img"></p>
<ul>
<li>将lilei用户添加到sudo用户组使用<code>**sudo usermod -G sudo lilei”**</code><strong>命令：</strong></li>
</ul>
<p>作用：</p>
<ul>
<li>“sudo” 用于以超级用户权限执行命令。</li>
<li>“usermod” 是修改用户属性的命令。</li>
<li>“-G” 选项用于指定用户所属的新的用户组列表，这里是将用户 “lilei” 加入 “sudo” 用户组。</li>
</ul>
<p><img src="/img/添加到用户组.png" alt="img"></p>
<p><em>（<strong>将lilei添加到sudo前后对比</strong>）</em></p>
<h2 id="3-4-删除用户和用户组"><a href="#3-4-删除用户和用户组" class="headerlink" title="3.4. 删除用户和用户组"></a>3.4. 删除用户和用户组</h2><ul>
<li>删除用户lilei是很简单的事：使用<code>sudo deluser lilei --remove-home</code>命令</li>
</ul>
<ol>
<li>“<code>sudo</code>”：用于以超级用户权限执行命令。</li>
<li>“<code>deluser</code>”：是删除用户的命令。</li>
<li>“<code>lilei</code>”：是要删除的用户的用户名。</li>
<li>“<code>--remove-home</code>”：这个选项表示<em>在<strong>**删除用户的同时，也删除该用户的主目录及其内容\</strong></em>。</li>
</ol>
<ul>
<li>删除用户组：使用<code>groupdel</code>命令：<code>groupdel groupname</code></li>
</ul>
<p>倘若该群组中仍包括某些用户，则必须先删除这些用户后，才能删除群组。</p>
<h1 id="4-Linux文件权限"><a href="#4-Linux文件权限" class="headerlink" title="4. Linux文件权限"></a>4. Linux文件权限</h1><h2 id="4-1-查看文件权限"><a href="#4-1-查看文件权限" class="headerlink" title="4.1. 查看文件权限"></a>4.1. 查看文件权限</h2><ul>
<li>使用较长格式列出文件：<code>ls -l</code></li>
</ul>
<p><img src="/img/列出文件.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2024/png/39155278/1727764489865-2dd57eee-e7b6-4ef2-8d46-062e66799470.png" alt="img"></p>
<p><img src="/img/用户组权限.png" alt="img"></p>
<ul>
<li>显示除了 <code>.</code>（当前目录）和 <code>..</code>（上一级目录）之外的所有文件，包括<strong>隐藏文件</strong>：<code>ls -a</code></li>
<li>显示所有文件大小:<code>ls -asSh</code></li>
<li><p>查看某一个目录完整属性：<code>ls -dl &lt;目录名&gt;</code></p>
</li>
<li><p>其中小 s 为显示文件大小，大 S 为按文件大小排序</p>
</li>
</ul>
<h2 id="4-2-变更文件所有者"><a href="#4-2-变更文件所有者" class="headerlink" title="4.2. 变更文件所有者"></a>4.2. 变更文件所有者</h2><ol>
<li>首先切换到<code>lilei</code>：<code>su - lilei</code></li>
<li>显示出当前目录：<code>pwd</code></li>
<li>新建一个文件，名为<code>iphone11</code></li>
<li>显示出<code>iphone11</code>的文件属性：<code>ls -alh ipone11</code>:</li>
</ol>
<p><img src="/img/iphone11.png" alt="img"></p>
<p>发现目前文件所有者属于<code>lilei</code>，于是接下来我们要将变更文件所有者为<code>shiyanlou</code>：</p>
<p><strong>步骤：</strong></p>
<ol>
<li>首先切换到<code>shiyanlou</code>用户：<code>su - shiyanlou</code></li>
<li>当前工作目录将变为 “<code>lilei</code>” 用户的主目录：<code>cd /home/lilei</code></li>
<li>将<code>iphone11</code>文件所有者改为<code>shiyanlou</code>：<code>*sudo chown shiyanlou iphone11*</code></li>
</ol>
<ul>
<li><p>“<code>chown</code>” 是用于改变文件所有者的命令</p>
</li>
<li><p>执行该命令后，“<code>iphone11</code>” 文件的所有者将被更改为 “<code>shiyanlou</code>” 用户</p>
</li>
</ul>
<h2 id="4-3-修改文件权限"><a href="#4-3-修改文件权限" class="headerlink" title="4.3. 修改文件权限"></a>4.3. 修改文件权限</h2><ol>
<li><p>文件权限有<em>两种表示方法</em>：</p>
</li>
<li><p>字母表示法：Linux文件权限分为<code>r</code>(读)、<code>w</code>(写)、<code>x</code>(执行)。每个文件针对所有者（<code>u</code>）、所属组(<code>g</code>)、其他用户<code>o</code>都有这三种权限，且所表示的顺序不变。</p>
</li>
</ol>
<ul>
<li>例如<code>rwxr-xr--</code>：拆分成每三个为一组，表示所有者有<code>读、写、执行</code>权限，所属组有<code>读和执行</code>权限，其他用户只有<code>读</code>权限。</li>
</ul>
<ol>
<li><p>数字表示法：用二进制数字的十进制值来表示：</p>
</li>
<li><p><code>读</code>对应<code>4</code>（100）</p>
</li>
<li><code>写</code>对应<code>2</code>（010）</li>
<li><code>执行</code>对应<code>1</code>（001）</li>
</ol>
<ul>
<li>例如<code>rwxr-xr--</code>可以用数字<code>754</code>表示，等价于写成<code>111``101``100</code></li>
</ul>
<ol>
<li><strong>使用</strong><code>**chmod**</code><strong>命令修改文件权限</strong></li>
</ol>
<p>如果将文件<code>iphone11</code>的权限更改为只有我自己可以使用，那么可以使用这个方法更改它的权限：</p>
<ul>
<li><code>chmod 600 iphone11</code>：作用是将<code>iphone11</code>文件的属性更改为只有<code>我自己(所有者)</code>进行读（r）写（w）操作</li>
</ul>
<ol>
<li><strong>使用加减赋值操作修改文件权限</strong></li>
</ol>
<ul>
<li><code>chmod go-rw iphone11</code>：去除所属组（g）和其他用户（o）的读（r）和写（w）权限</li>
</ul>
<p>初始权限为 “<code>-rw-rw-r--</code>”→执行命令后权限变为 “<code>-rw------</code>”</p>
<p><code>+</code> 和 <code>-</code> 分别表示增加和去掉相应的权限</p>
<h2 id="4-4-adduser-和-useradd-的区别"><a href="#4-4-adduser-和-useradd-的区别" class="headerlink" title="4.4. adduser 和 useradd 的区别"></a>4.4. <code>adduser</code> 和 <code>useradd</code> 的区别</h2><p><strong>答：</strong><code>useradd</code> 只创建用户，不会创建用户密码和工作目录，创建完了需要使用 <code>passwd &lt;username&gt;</code> 去设置新用户的密码。<code>adduser</code> 在创建用户的同时，会创建工作目录和密码（提示你设置），做这一系列的操作。其实 <code>useradd</code>、<code>userdel</code> 这类操作更像是一种命令，执行完了就返回。而 <code>adduser</code> 更像是一种程序，需要你输入、确定等一系列操作。</p>
<h2 id="4-5-作业"><a href="#4-5-作业" class="headerlink" title="4.5. 作业"></a>4.5. 作业</h2><p>要求：添加一个用户<code>loutest</code>，使用<code>sudo</code>创建文件<code>/opt/forloutest</code>，设置成用户<code>loutest</code>可以读写。</p>
<ol>
<li>添加用户<code>loutest</code>：</li>
</ol>
<ul>
<li>使用<code>adduser</code>命令添加用户。</li>
<li>在终端中执行<code>sudo adduser loutest</code>。</li>
</ul>
<ol>
<li>将用户<code>loutest</code>添加到<code>sudo</code>组以获得<code>sudo</code>权限：</li>
</ol>
<ul>
<li>编辑<code>sudoers</code>文件，执行<code>sudo visudo</code>。</li>
<li>在文件中找到类似 “% sudo ALL=(ALL:ALL) ALL” 的行，在其下方添加 “loutest ALL=(ALL:ALL) ALL”，保存并退出。</li>
</ul>
<ol>
<li>创建文件并设置权限：</li>
</ol>
<ul>
<li>以具有<code>sudo</code>权限的用户（比如当前用户是<code>root</code>或者已经被授权<code>sudo</code>权限的用户）执行<code>sudo touch /opt/forloutest</code>创建文件。</li>
<li>然后执行<code>sudo chown loutest:loutest /opt/forloutest</code>将文件的所有者设置为<code>loutest</code>用户。</li>
<li>接着执行<code>sudo chmod u+rwx,g+rwx,o+rwx /opt/forloutest</code>设置文件权限为用户<code>loutest</code>可读、可写、可执行，所属组和其他用户也具有相同权限（如果只需要用户<code>loutest</code>可读写，可以使用<code>sudo chmod u+rw /opt/forloutest</code>）。</li>
</ul>
<h1 id="5-Linux目录结构及文件基本操作"><a href="#5-Linux目录结构及文件基本操作" class="headerlink" title="5. Linux目录结构及文件基本操作"></a>5. Linux目录结构及文件基本操作</h1><h2 id="5-1-FHS标准"><a href="#5-1-FHS标准" class="headerlink" title="5.1. FHS标准"></a>5.1. FHS标准</h2><ol>
<li><code>/bin</code>：</li>
</ol>
<ul>
<li>存放基本的用户命令二进制文件，这些命令在单用户模式下也需要使用，并且所有用户都可以执行。例如 <code>cat</code>、<code>ls</code>、<code>cp</code> 等常用命令。</li>
</ul>
<ol>
<li><code>/sbin</code>：</li>
</ol>
<ul>
<li>包含系统管理员使用的二进制文件。例如 <code>ifconfig</code>、<code>route</code>、<code>fdisk</code> 等用于系统管理和维护的命令。</li>
</ul>
<ol>
<li><code>/usr/bin</code> 和 <code>/usr/sbin</code>：</li>
</ol>
<ul>
<li><code>/usr/bin</code> 存放非必要的用户命令二进制文件，通常是一些较大型的软件包安装的命令。</li>
<li><code>/usr/sbin</code> 存放非必要的系统管理二进制文件。</li>
</ul>
<ol>
<li><code>/etc</code>：</li>
</ol>
<ul>
<li>存放系统配置文件。例如 <code>/etc/passwd</code>（用户账户信息）、<code>/etc/group</code>（用户组信息）、<code>/etc/fstab</code>（文件系统挂载配置）等。</li>
</ul>
<ol>
<li><code>/dev</code>：</li>
</ol>
<ul>
<li>包含设备文件。这些文件代表了系统中的硬件设备，例如硬盘、打印机、鼠标等。通过访问这些设备文件，操作系统可以与硬件进行交互。</li>
</ul>
<ol>
<li><code>/proc</code>：</li>
</ol>
<ul>
<li>这是一个虚拟文件系统，提供了关于正在运行的进程和内核的信息。例如，可以通过查看 <code>/proc/cpuinfo</code> 了解 CPU 信息，查看 <code>/proc/meminfo</code> 了解内存使用情况。</li>
</ul>
<ol>
<li><code>/var</code>：</li>
</ol>
<ul>
<li>存放可变数据文件，如日志文件、邮件队列、打印队列等。随着系统的运行，这些文件的内容会不断变化。</li>
</ul>
<ol>
<li><code>/home</code>：</li>
</ol>
<ul>
<li>用户主目录的存放位置。每个用户在这个目录下都有一个以其用户名命名的子目录，用于存放用户的个人文件和设置。</li>
</ul>
<ol>
<li><code>/root</code>：</li>
</ol>
<ul>
<li>超级用户（root）的主目录。</li>
</ul>
<ol>
<li><code>/lib</code> 和 <code>/usr/lib</code>：</li>
</ol>
<ul>
<li>存放库文件。库文件包含了可被程序调用的函数和代码，分为静态库和动态库。<code>/lib</code> 存放基本的系统库，而 <code>/usr/lib</code> 存放非必要的库文件。</li>
</ul>
<ol>
<li><code>**/opt**</code>：</li>
</ol>
<ul>
<li>通常用于存放可选的、第三方软件包。这些软件包通常不是系统默认安装的，而是由用户根据需要自行安装的。</li>
</ul>
<ol>
<li><code>**/tmp**</code><strong>：</strong></li>
</ol>
<ul>
<li>存放临时文件。这些文件在系统运行过程中临时产生，并且可以在系统重新启动时被删除。</li>
</ul>
<h2 id="5-2-目录路径"><a href="#5-2-目录路径" class="headerlink" title="5.2. 目录路径"></a>5.2. 目录路径</h2><p><strong>路径：</strong></p>
<ul>
<li><code>~</code>：表示当前用户的<code>home</code>目录</li>
<li><code>-</code>：表示上一次所在的目录</li>
<li><code>.</code>：表示当前目录</li>
<li><code>..</code>：表示上一级目录</li>
</ul>
<p><strong>绝对路径：</strong>简单地说就是以根” / “目录为起点的完整路径</p>
<p><strong>相对路径：</strong>相对于你当前的目录的路径</p>
<p>现在以你的 <code>**home**</code> 目录为起点，分别以绝对路径和相对路径的方式进入 <code>/usr/local/bin</code> 目录：</p>
<ol>
<li>绝对路径</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/bin</span><br></pre></td></tr></table></figure>
<p>从根目录”<code>/</code>“出发，经过 “<code>usr</code>” 目录、“<code>local</code>” 目录，最后到达 “<code>bin</code>” 目录的路径</p>
<ol>
<li>相对路径</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ../../usr/local/bin</span><br></pre></td></tr></table></figure>
<ul>
<li>首先向上两级目录，即从 “<code>/home/your_username</code>” 到 “<code>/home</code>”，再到 “<code>/</code>”，然后进入 “<code>usr</code>”、“<code>local</code>” 和 “<code>bin</code>” 目录，最终也到达 “<code>/usr/local/bin</code>”。</li>
</ul>
<h2 id="5-3-Linux文件的基本操作"><a href="#5-3-Linux文件的基本操作" class="headerlink" title="5.3. Linux文件的基本操作"></a>5.3. Linux文件的基本操作</h2><h3 id="5-3-1-新建"><a href="#5-3-1-新建" class="headerlink" title="5.3.1. 新建"></a>5.3.1. 新建</h3><p><strong>新建空白文件：</strong></p>
<ul>
<li><code>touch</code>：<code>touch test</code>创建一个名为<code>test</code>的空白文件</li>
</ul>
<p>若当前目录存在一个 test 文件夹，则 <code>touch</code> 命令，则会更改该文件夹的时间戳而不是新建文件。</p>
<p><strong>新建目录：</strong></p>
<ul>
<li><code>mkdir</code>：<code>mkdir mydir</code>创建名为<code>mydir</code>的空目录</li>
</ul>
<p>使用<code>-p</code>，同时创建父目录 </p>
<p>当使用<code>mkdir -p</code>时，它可以一次性创建多级目录结构，即使上级目录不存在也会自动创建</p>
<ul>
<li>假设要创建一个目录结构为<code>/path/to/new/directory</code>，可以使用以下命令：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /path/to/new/directory</span><br></pre></td></tr></table></figure>
<p>如果<code>/path/to</code>和<code>/path/to/new</code>这两个目录都不存在，使用这个命令会自动创建它们，然后再创建最后的<code>directory</code>目录。</p>
<h3 id="5-3-2-复制"><a href="#5-3-2-复制" class="headerlink" title="5.3.2. 复制"></a>5.3.2. 复制</h3><ol>
<li>使用<code>cp</code>命令：复制”<strong>一个文件”</strong>到指定目录。</li>
</ol>
<p>使用之前创建的<code>test</code>文件复制到<code>/home/shiyanlou/father/son/grandson</code>目录中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp test father/son/grandson</span><br></pre></td></tr></table></figure>
<ol>
<li>使用<code>cp</code>命令：将文件的内容复制到当前目录下的一个新文件中</li>
</ol>
<p><strong>格式：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> [选项]... 源文件 目标文件</span><br><span class="line"><span class="built_in">cp</span> /etc/passwd passwd <span class="comment">#将 /etc/passwd 文件的内容复制到当前目录下的一个新文件 passwd </span></span><br></pre></td></tr></table></figure>
<p><strong>复制目录</strong></p>
<p><strong>错误</strong>：如果直接使用<code>cp</code>命令复制一个目录会出错。</p>
<p>想要成功复制目录，需要加上<code>-r</code>或者<code>-R</code>参数，表示递归复制：</p>
<ul>
<li><code>cp -R father family</code>：递归地将 <code>father</code> 目录复制到 <code>family</code> 目录中。</li>
</ul>
<h3 id="5-3-3-删除"><a href="#5-3-3-删除" class="headerlink" title="5.3.3. 删除"></a>5.3.3. 删除</h3><ul>
<li><p><code>rm</code>：“remove”删除一个文件<code>rm test</code></p>
</li>
<li><p><code>-f</code>：”force”表示强制删除一个文件，忽略删除文件时候的提示，如<code>rm -f test</code></p>
</li>
</ul>
<p><strong>删除目录：</strong></p>
<p>跟复制目录一样，要删除一个目录，也需要加上<code>-r</code>或<code>-R</code>参数</p>
<p>如：<code>rm -r family</code></p>
<ul>
<li>如果遇到<strong>权限不足，可以加上</strong><code>**-f**</code><strong>参数强制删除：</strong><code>**rm -rf family**</code></li>
</ul>
<h3 id="5-3-4-移动文件与文件重命名"><a href="#5-3-4-移动文件与文件重命名" class="headerlink" title="5.3.4. 移动文件与文件重命名"></a>5.3.4. 移动文件与文件重命名</h3><p><strong>移动文件：</strong></p>
<ul>
<li><code>mv</code>：格式为<code>mv 源目录文件 目的目录</code></li>
</ul>
<p>示例：例如在当前目录创建一个<code>file1</code>文件和<code>Document</code>目录，接着把<code>file1</code>移动到<code>Documents</code>目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir Documents</span><br><span class="line">touch file1</span><br><span class="line">mv file1 Document</span><br></pre></td></tr></table></figure>
<p><strong>重命名文件：</strong></p>
<ul>
<li><code>mv</code>:格式为<code>mv 旧的文件名 新的文件名</code></li>
</ul>
<p>示例：<code>mv file1 myfile</code></p>
<p><strong>批量重命名：</strong></p>
<ol>
<li>安装（部分系统可能需要安装）：</li>
</ol>
<ul>
<li>在一些 Linux 发行版中，可能需要安装 <code>rename</code> 命令。例如在 Debian/Ubuntu 系统中，可以使用 <code>sudo apt install rename</code> 进行安装。</li>
</ul>
<ol>
<li>用法：</li>
</ol>
<ul>
<li><code>rename</code> 命令可以基于正则表达式进行批量重命名。</li>
<li>例如，将当前目录下所有以 <code>.txt</code> 结尾的文件的扩展名改为 <code>.md</code>，可以使用 <code>rename &#39;s/\.txt$/.md/&#39; *.txt</code>。</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="5-3-5-查看文件"><a href="#5-3-5-查看文件" class="headerlink" title="5.3.5. 查看文件"></a>5.3.5. 查看文件</h3><ul>
<li>使用<code>cat</code>、<code>tac</code>和<code>nl</code>命令查看文件</li>
</ul>
<ol>
<li><code>cat</code>命令：正序显示文件内容（联想：猫（<code>cat</code>）喜欢看东西）</li>
</ol>
<ul>
<li><code>-b</code>：对行进行编号，不包括空行。</li>
<li><code>-A</code>：会显示文件中的所有内容，包括不可打印字符</li>
<li><code>-n</code>：对所有行进行编号，包括空行。（联想：<code>-n</code>可以联想到<code>number</code>单词，编号）</li>
<li><code>-E</code>：在每一行的末尾显示一个 <code>$</code> 符号。</li>
<li>例如：可以加上<code>-n</code>参数显示行号：<code>cat -n passwd</code></li>
<li><img src="/img/cat-n.png" alt="img"></li>
</ul>
<ol>
<li><code>tac</code>（想象成<code>cat</code>反过来写）命令：倒序显示文件内容</li>
<li><code>nl</code>命令(<code>number lines</code>编号的缩写)：用于显示文件内容，并在每行前面加上行号。</li>
</ol>
<ul>
<li><code>-ba</code>：所有行都编号，包括空行。</li>
<li><code>-bn</code>：只对非空行编号。</li>
<li><code>-p</code>：将文件内容和行号一起输出。</li>
<li><code>-wN</code>：设置行号的宽度为 <code>N</code></li>
</ul>
<p><strong>使用</strong><code>**more**</code><strong>和</strong><code>**less**</code><strong>命令分页查看文件</strong></p>
<ul>
<li><code>cat</code> 是用来快速查看一个文件的内容的，那么这个 <code>more</code> 和 <code>less</code> 就是天生用来”阅读”一个文件的内容的</li>
<li><code>less</code>命令：用于分页显示文件内容，允许用户向前和向后浏览文件</li>
<li><code>more</code>命令：用于分页显示文件内容，一次显示一页内容，<code>more</code> 只能向前浏览</li>
</ul>
<p><strong>使用</strong><code>**head**</code><strong>和</strong><code>**tail**</code><strong>命令查看文件</strong></p>
<ul>
<li>对于非常大的文件，使用 <code>head</code> 和 <code>tail</code> 可以<strong>只查看文件的头几行</strong>和<strong>尾几行</strong></li>
</ul>
<ul>
<li><p><code>head</code>命令：输出文件的开始部分，默认情况下显示文件的前10行</p>
</li>
<li><p><code>-n [行数]</code>：显示文件开头的指定行数。</p>
</li>
<li><p>例如<code>head -n 20 filename</code>，显示文件的前20行</p>
</li>
<li><p><code>tail</code>命令：输出文件的最后部分，默认情况下显示文件的最后10行</p>
</li>
<li><p><code>-n [行数]</code>：显示文件末尾的指定行数。</p>
</li>
<li><code>-f</code>：以实现不停地读取某个文件的内容并显示。这可以让我们动态查看日志，达到实时监视的目的</li>
</ul>
<h3 id="5-3-6-查看文件类型"><a href="#5-3-6-查看文件类型" class="headerlink" title="5.3.6. 查看文件类型"></a>5.3.6. 查看文件类型</h3><ul>
<li><p><code>file</code> 命令：用于查看文件的类型。</p>
</li>
<li><p>在 Linux 中，文件类型不是根据文件后缀名来判断的，而是根据文件内容（创建的空文件，使用 <code>file</code> 命令查看时会显示为空）</p>
</li>
</ul>
<h3 id="5-3-7-编辑文件"><a href="#5-3-7-编辑文件" class="headerlink" title="5.3.7. 编辑文件"></a>5.3.7. 编辑文件</h3><p>在 Linux 下面编辑文件通常我们会直接使用专门的命令行编辑器比如（<code>emacs</code>，<code>vim</code>，<code>nano</code>）</p>
<h2 id="5-4-更多"><a href="#5-4-更多" class="headerlink" title="5.4. 更多"></a>5.4. 更多</h2><p>召唤一双眼睛来监督学习：<code>xeyes</code></p>
<p><img src="/img/xeyes.png" alt="img"></p>
<p>把它放到后台：<code>nohup xeyes &amp;</code>，输入这段命令，终端会输出一个<code>PID</code>，也就是<code>xeyes</code>的进程号。</p>
<p>关闭<code>xeyes</code>：使用<code>kill</code>命令，杀死PID进程，<code>sudo kill -9 PID号</code></p>
<h2 id="5-5-作业"><a href="#5-5-作业" class="headerlink" title="5.5. 作业"></a>5.5. 作业</h2><ol>
<li>创建一个 homework 目录，建立名为 1.txt ～ 10.txt 文件，并删除 1.txt ～ 5.txt</li>
<li>Linux 的日志文件在哪个目录？</li>
</ol>
<p>答案：</p>
<ol>
<li><code>mkdir homework</code>→<code>touch &#123;1..10&#125;.txt</code>→<code>rm &#123;1..5&#125;.txt</code></li>
<li><code>**/var/log**</code>：</li>
</ol>
<ul>
<li>这是最常用的日志文件存放目录。</li>
<li>包含了系统和大部分应用程序的日志。</li>
</ul>
<h1 id="6-环境变量与文件查找"><a href="#6-环境变量与文件查找" class="headerlink" title="6. 环境变量与文件查找"></a>6. 环境变量与文件查找</h1><h2 id="6-1-环境变量"><a href="#6-1-环境变量" class="headerlink" title="6.1. 环境变量"></a>6.1. 环境变量</h2><p><strong>变量：</strong></p>
<p>准确的说应该是<code>Shell</code> 变量，所谓变量就是计算机中用于记录一个值<code>Shell</code>变量就是用于记录一个值的标识符。这个值可以是数字、字符或者字符串等，变量在程序中可以被用来进行各种操作，比如计算、比较等</p>
<ul>
<li>创建变量：</li>
</ul>
<p>使用<code>declare</code>命令创建一个名为<code>tmp</code>的变量：<code>declare tmp</code></p>
<p>其实也可以不用<code>declare</code>声明，即用即创建：<code>tmp</code></p>
<p><strong>注意：变量名只能是英文字母、数字或者下划线，且不能以数字作为开头！</strong></p>
<ul>
<li>赋值运算符：</li>
</ul>
<p>使用<code>=</code>：例如，<code>tmp=shiyanlou</code>【<code>=</code>两边不能有空格，否则会报错】</p>
<ul>
<li>读取变量的值：</li>
</ul>
<p>使用<code>echo</code>命令和<code>$</code>符号：<code>echo $tmp</code></p>
<p><strong>环境变量</strong></p>
<p>关于哪些变量是环境变量，可以简单地理解成在当前进程的子进程有效则为环境变量，否则不是</p>
<ul>
<li><code>set</code>命令：显示当前<code>Shell</code>所有变量，包括其内建环境变量（与Shell外观等相关），用户自定义变量及导出的环境变量</li>
<li><code>env</code>命令：显示与当前用户相关的环境变量，还可以让命令在指定环境中运行</li>
<li><code>export</code>命令：显示从Shell中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量。</li>
</ul>
<p><strong>设置</strong></p>
<ul>
<li><strong>临时环境变量</strong>：在当前shell会话中设置的环境变量，只在当前会话有效。可以通过<code>export VAR=value</code>命令设置。</li>
<li><strong>持久环境变量</strong>：在用户的配置文件（如<code>~/.bashrc</code>或<code>/etc/profile</code>）中设置的环境变量，每次新开shell时都会加载。</li>
</ul>
<p>所以如果想要添加一个永久生效的环境变量，只需要打开 <code>/etc/profile</code>，在最后加上你想添加的环境变量就好啦。</p>
<h2 id="6-2-命令的查找路径与顺序"><a href="#6-2-命令的查找路径与顺序" class="headerlink" title="6.2. 命令的查找路径与顺序"></a>6.2. 命令的查找路径与顺序</h2><p><strong>思考：</strong>我们在Shell中输入一个命令，Shell是怎么知道去哪找到这个命令然后执行的呢？</p>
<p>——实际上是通过<em>环境变量</em><code>PATH</code>来进行搜索的</p>
<ul>
<li>查看<code>PATH</code>环境变量的内容：<code>echo $PATH</code></li>
<li><p>默认情况下会看到如下输出：<code>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</code></p>
</li>
<li><p>通常这一类目录下放的都是可执行文件，当我们在 Shell 中执行一个命令时，系统就会按照 PATH 中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。</p>
</li>
</ul>
<ul>
<li><strong>创建一个Shell脚本文件：</strong></li>
</ul>
<p>可以使用<code>gedit</code>、<code>vim</code>、<code>sublime</code>等工具编辑</p>
<ol>
<li>导航到<code>home</code>：<code>cd /home/shiyanlou</code></li>
<li>创建<code>hello_shell.sh</code>脚本文件：<code>touch hello_shell.sh</code></li>
<li>在<code>gedit</code>编辑器中编辑脚本：<code>gedit hello_shell.sh</code></li>
<li>在脚本中输入如下内容：<strong>注意不要省掉第一行</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++));<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;hello shell&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<ol>
<li>为文件添加可执行权限，否则执行会报错没有权限：<code>chmod 755 hello_shell.sh</code></li>
<li>执行脚本：<code>cd /home/shiyanlou</code>  <code>./hello_shell.sh</code></li>
</ol>
<ul>
<li><strong>创建一个C语言</strong><code>**hello world**</code><strong>程序</strong></li>
</ul>
<ol>
<li>导航到<code>home</code>：<code>cd /home/shiyanlou</code></li>
<li>使用<code>gedit</code>编辑器编辑代码：<code>gedit hello_world.c</code></li>
<li>编辑代码：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编译成可执行文件：<code>gcc -o hello_world hello_world.c</code></li>
<li>执行<code>./hello_world</code></li>
</ol>
<ul>
<li>为什么在Linux中创建的.sh文件可以直接执行，而创建的.c文件需要先执行gcc -o?</li>
<li><strong>Shell 脚本（.sh 文件）</strong>：是解释执行的脚本文件，直接由Shell解释器逐行解释并执行，只需赋予可执行权限即可运行。</li>
<li><strong>C 源代码（.c 文件）</strong>：是需要编译的源代码文件，必须先通过编译器编译成可执行文件，然后才能运行。</li>
</ul>
<h2 id="6-3-添加自定义路径到”PATH”环境变量"><a href="#6-3-添加自定义路径到”PATH”环境变量" class="headerlink" title="6.3. 添加自定义路径到”PATH”环境变量"></a>6.3. 添加自定义路径到”PATH”环境变量</h2><p><strong>临时功效：</strong> <code>PATH=$PATH:/home/shiyanlou/mybin</code>( 注意这里一定要使用绝对路径 )，这样就可以在任意目录中执行<code>hello_shell.sh</code>和<code>hello_world.sh</code>这两个可执行文件了【注意要去掉前面的<code>./</code>】</p>
<p><strong>持久功效：</strong>若想要在shell每次启动时候都保持添加的环境变量有效，则就要配置脚本文件了</p>
<p><strong>配置文件：</strong>可以使用<code>cat /etc/shells</code>命令查看当前系统已安装的Shell</p>
<ol>
<li>若使用的 Shell 是 <code>zsh</code>，则配置文件是<code>.zshrc</code></li>
<li>若使用的 Shell 是 <code>Bash</code>，则配置文件是<code>.bashrc</code></li>
</ol>
<ul>
<li>直接添加内容到 <code>.zshrc</code> 中：<code>echo&quot;PATH=$PATH:/home/shiyanlou/mybin&quot; &gt;&gt; .zshrc</code></li>
</ul>
<p><code>**&gt;&gt;**</code><strong>： 表示将标准输出以追加的方式重定向到一个文件中</strong></p>
<p> <code>**&gt;**</code> <strong>：是以覆盖的方式重定向到一个文件中</strong></p>
<p>在指定文件不存在的情况下都会创建新的文件</p>
<h2 id="6-4-修改和删除已有变量"><a href="#6-4-修改和删除已有变量" class="headerlink" title="6.4. 修改和删除已有变量"></a>6.4. 修改和删除已有变量</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>变量设置方式</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$&#123;变量名#匹配字串&#125;</code></td>
<td>从头向后开始匹配，删除符合匹配字串的最短数据</td>
</tr>
<tr>
<td><code>$&#123;变量名##匹配字串&#125;</code></td>
<td>从头向后开始匹配，删除符合匹配字串的最长数据</td>
</tr>
<tr>
<td><code>$&#123;变量名%匹配字串&#125;</code></td>
<td>从尾向前开始匹配，删除符合匹配字串的最短数据</td>
</tr>
<tr>
<td><code>$&#123;变量名%%匹配字串&#125;</code></td>
<td>从尾向前开始匹配，删除符合匹配字串的最长数据</td>
</tr>
<tr>
<td><code>$&#123;变量名/旧的字串/新的字串&#125;</code></td>
<td>将符合旧字串的第一个字串替换为新的字串</td>
</tr>
<tr>
<td><code>$&#123;变量名//旧的字串/新的字串&#125;</code></td>
<td>将符合旧字串的全部字串替换为新的字串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mypath=<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$mypath</span></span><br><span class="line"></span><br><span class="line">mypath=<span class="variable">$&#123;mypath%/home/shiyanlou/mybin&#125;</span></span><br><span class="line">mypath=<span class="variable">$&#123;path%*/mybin&#125;</span></span><br></pre></td></tr></table></figure>
<p>第二行命令比第一行更通用，因为它会删除任何以<code>/mybin</code>结尾的路径，而不仅仅是<code>/home/shiyanlou/mybin</code></p>
<p>如果<code>PATH</code>的初始值是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/bin:/bin:/usr/bin:/home/shiyanlou/mybin</span><br></pre></td></tr></table></figure>
<p>执行上述脚本后，<code>mypath</code>的值将会是：</p>
<p><code>/usr/local/bin:/bin:/usr/bin</code>，因为<code>/home/shiyanlou/mybin</code>被从尾部删除了。</p>
<h2 id="6-5-如何让环境变量立即生效"><a href="#6-5-如何让环境变量立即生效" class="headerlink" title="6.5. 如何让环境变量立即生效"></a>6.5. 如何让环境变量立即生效</h2><p>在Shell环境下，当你修改了某个配置脚本文件（比如<code>zsh</code>的配置文件，位于用户主目录下的<code>.zshrc</code>文件），通常需要退出当前的终端会话，重新打开一个新的终端，或者重启计算机，这样修改后的配置才能生效。这样做可能会有些不便。</p>
<p>为了解决这个问题，可以使用<code>source</code>命令（在某些Shell中也称为<code>.</code>命令）：<code>**source .zshrc**</code></p>
<p>【等价于<code>. ./.zshrc</code>】</p>
<h2 id="6-6-搜索文件"><a href="#6-6-搜索文件" class="headerlink" title="6.6. 搜索文件"></a>6.6. 搜索文件</h2><p>与搜索相关的命令常用的有<code>whereis</code>、<code>which</code>、<code>find</code>和<code>locate</code></p>
<p><strong>区分：</strong></p>
<ul>
<li><strong>速度</strong>：<code>locate</code>通常是最快的，因为它使用数据库；<code>find</code>可能最慢，因为它遍历文件系统。</li>
<li><strong>实时性</strong>：<code>which</code>和<code>find</code>提供最新的搜索结果，因为它们直接在文件系统中搜索；<code>locate</code>的结果可能不是最新的，因为它依赖于数据库的更新。</li>
<li><strong>搜索范围</strong>：<code>which</code>仅限于<code>$PATH</code>环境变量定义的目录；<code>find</code>可以在整个文件系统或指定目录下搜索；<code>locate</code>和<code>whereis</code>可以搜索整个文件系统。</li>
<li><strong>搜索内容</strong>：<code>whereis</code>可以同时查找二进制、源和手册页文件；<code>which</code>只查找二进制文件；<code>find</code>和<code>locate</code>可以查找任何类型的文件。</li>
</ul>
<ul>
<li><code>whereis</code>简单快速：只能搜索二进制文件（<code>-b</code>），man 帮助文件（<code>-m</code>）和源代码文件（<code>-s</code>）</li>
</ul>
<p>示例：输入<code>whereis find</code>命令<img src="/img/whereis.png" alt="img"></p>
<p>会看到<code>whereis find</code>找到了三个路径，两个可执行文件路径和一个<code>man</code>在线帮助文件所在路径，这个搜索很快，因为直接是<strong>从数据库中查询</strong>，而不是从硬盘中查找</p>
<ul>
<li><code>**locate**</code><strong>快而全</strong>：使用预建的数据库来查找文件，非常快，依赖于数据库的更新，通过查询 <code>/var/lib/mlocate/mlocate.db</code> 数据库来检索信息</li>
<li>如果想只统计数目可以加上 <code>-c</code> 参数，<code>-i</code> 参数可以忽略大小写进行查找，<code>whereis</code> 的 <code>-b</code>、<code>-m</code>、<code>-s</code> 同样可以使用。</li>
</ul>
<p>系统会使用定时任务每天自动执行 <code>updatedb</code> 命令来更新数据库，手动执行一次 <code>updatedb</code> 命令也可以更新刚刚添加的文件（这个命令不是内置命令，可能需要手动安装，然后执行更新）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install locate</span><br><span class="line"><span class="built_in">sudo</span> updatedb</span><br></pre></td></tr></table></figure>
<p>示例：查询<code>/etc</code>下所有以<code>sh</code>开头的文件：<code>locate /etc/sh</code></p>
<p><strong>注意，它不只是在 /etc 目录下查找，还会自动递归子目录进行查找</strong></p>
<p>查找 <code>/usr/share/</code> 下所有 jpg 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locate /usr/share/*.jpg</span><br></pre></td></tr></table></figure>
<ul>
<li><code>**which**</code><strong>小而精**</strong>：**通常使用 <code>which</code> 来确定是否安装了某个指定的程序【也就是说，我们可以看到某个系统命令是否存在以及执行的到底是哪一个地方的命令。】</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> man</span><br><span class="line"><span class="built_in">which</span> nginx</span><br><span class="line"><span class="built_in">which</span> ping</span><br></pre></td></tr></table></figure>
<ul>
<li><code>**find**</code><strong>精而细，最强大：**</strong>基本命令格式为<strong>` </strong>find [path][option] [action]** ` 不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索</li>
</ul>
<p>最常见的使用示例：去<code>/etc/</code>目录下面，搜索名字叫做<code>interfaces</code>的文件或者目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /etc/ -name interfaces</span><br></pre></td></tr></table></figure>
<p>与时间相关的命令参数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-atime</code></td>
<td>最后访问时间</td>
</tr>
<tr>
<td><code>-ctime</code></td>
<td>最后修改文件内容的时间</td>
</tr>
<tr>
<td><code>-mtime</code></td>
<td>最后修改文件属性的时间</td>
</tr>
</tbody>
</table>
</div>
<p><code>-mtime</code> 参数举例：</p>
<ul>
<li><code>-mtime n</code>：n 为数字，表示为在 n 天之前的“一天之内”修改过的文件</li>
<li><code>-mtime +n</code>：列出在 n 天之前（不包含 n 天本身）被修改过的文件</li>
<li><code>-mtime -n</code>：列出在 n 天之内（包含 n 天本身）被修改过的文件</li>
<li><code>-newer file</code>：file 为一个已存在的文件，列出比 file 还要新的文件名</li>
</ul>
<p><img src="/img/过去现在.png" alt="img"></p>
<ul>
<li>列出 <code>home</code> 目录中，当天（24 小时之内）有改动的文件：<code>find ~ -mtime 0</code></li>
<li>列出用户家目录下比 <code>/etc</code>目录新的文件：<code>find ~ -newer /etc</code></li>
</ul>
<h2 id="6-7-更多"><a href="#6-7-更多" class="headerlink" title="6.7. 更多"></a>6.7. 更多</h2><p><strong>代码数字雨</strong></p>
<p>《黑客帝国》电影里满屏幕代码的“数字雨”，在 Linux 里面你也可以轻松实现这样的效果，你只需要一个命令 <code>cmatrix</code> 。</p>
<p>需要先安装，因为 Ubuntu 没有预装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install cmatrix</span><br></pre></td></tr></table></figure>
<p>装好之后先不要急着执行，为了看到更好的效果，我们需要先修改终端的主题配色，在终端上面菜单栏中找到[首选项]修改，修改颜色预设为黑底绿字。</p>
<p><img src="/img/数字代码雨.png" alt="img"></p>
<p>然后输入 <code>cmatrix</code> 开始运行</p>
<p>还可以改变代码的颜色：<code>cmatrix -C red</code></p>
<h2 id="6-8-作业"><a href="#6-8-作业" class="headerlink" title="6.8. 作业"></a>6.8. 作业</h2><ul>
<li>寻找文件</li>
</ul>
<p>找出 <code>/etc/</code> 目录下的所有以 <code>.list</code> 结尾的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find /etc/ -<span class="built_in">type</span> f -name <span class="string">&quot;*.list&quot;</span></span><br><span class="line">在这也可以使用：</span><br><span class="line">find /etc/ -name <span class="string">&quot;*.list&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里是命令参数的解释：</p>
<ul>
<li><code>/etc/</code>：指定搜索的起始目录。</li>
<li><code>-type f</code>：指定你要找的是文件（file）。</li>
<li><code>-name &quot;*.list&quot;</code>：指定搜索的文件名模式，<code>*</code>是一个通配符，表示任意数量的任意字符，所以<code>*.list</code>表示任何以<code>.list</code>结尾的文件。</li>
</ul>
<h1 id="7-挑战：寻找文件"><a href="#7-挑战：寻找文件" class="headerlink" title="7. 挑战：寻找文件"></a>7. 挑战：寻找文件</h1><p><strong>介绍</strong></p>
<p>有一个非常重要的文件（<code>sources.list</code>）但是你忘了它在哪了，你依稀记得它在 <code>/etc/</code> 目录下，现在要你把这个文件找出来，然后设置成自己（shiyanlou 用户）可以访问，但是其他用户并不能访问。</p>
<p><strong>目标</strong></p>
<ol>
<li>找到 <code>sources.list</code> 文件</li>
<li>把文件所有者改为自己（shiyanlou）</li>
<li>把权限修改为仅仅只有自己可读可写</li>
</ol>
<p><strong>提示语</strong></p>
<ul>
<li>find</li>
<li>chmod</li>
<li>chown</li>
<li>sudo</li>
</ul>
<p>注意：如果是实验楼的海外用户，由于环境差异可能会找到两个 <code>sources.list</code> 文件，不需要修改 shiyanlou 目录下的 <code>sources.list</code>，因为这个文件是从实验环境外部挂载到环境中的，是无法修改的</p>
<p><strong>参考答案</strong></p>
<p>注意：请务必自己独立思考解决问题之后再对照参考答案，一开始直接看参考答案收获不大</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> find /etc -name sources.list  <span class="comment">#使用find命令查找到</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> shiyanlou /etc/apt/sources.list <span class="comment">#使用chown命令改变文件所有者</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 600 /etc/apt/sources.list  <span class="comment">#使用chmod命令改变文件权限</span></span><br></pre></td></tr></table></figure>
<h1 id="8-文件打包与解压缩"><a href="#8-文件打包与解压缩" class="headerlink" title="8. 文件打包与解压缩"></a>8. 文件打包与解压缩</h1><h2 id="8-1-常见压缩包格式"><a href="#8-1-常见压缩包格式" class="headerlink" title="8.1. 常见压缩包格式"></a>8.1. 常见压缩包格式</h2><ul>
<li><code>windows</code>中常见的这两种：<code>*.zip</code>和<code>*.7z</code>后缀的压缩文件</li>
<li><code>Linux</code>中除了上面两种外，还有<code>*.rar</code>、<code>*.gz</code>、<code>*.xz</code>、<code>*.bz2</code>、<code>*.tar</code>、<code>*.tar.gz</code>、<code>*.tar.bz2</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>文件后缀名</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*.zip</code></td>
<td>zip 程序打包压缩的文件</td>
</tr>
<tr>
<td><code>*.rar</code></td>
<td>rar 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.7z</code></td>
<td>7zip 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar</code></td>
<td>tar 程序打包，未压缩的文件</td>
</tr>
<tr>
<td><code>*.gz</code></td>
<td>gzip 程序（GNU zip）压缩的文件</td>
</tr>
<tr>
<td><code>*.xz</code></td>
<td>xz 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.bz2</code></td>
<td>bzip2 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar.gz</code></td>
<td>tar 打包，gzip 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar.xz</code></td>
<td>tar 打包，xz 程序压缩的文件</td>
</tr>
<tr>
<td><code>*tar.bz2</code></td>
<td>tar 打包，bzip2 程序压缩的文件</td>
</tr>
<tr>
<td><code>*.tar.7z</code></td>
<td>tar 打包，7z 程序压缩的文件</td>
</tr>
</tbody>
</table>
</div>
<h2 id="8-2-打包压缩和解压缩"><a href="#8-2-打包压缩和解压缩" class="headerlink" title="8.2. 打包压缩和解压缩"></a>8.2. 打包压缩和解压缩</h2><h3 id="8-2-1-zip压缩打包程序"><a href="#8-2-1-zip压缩打包程序" class="headerlink" title="8.2.1. zip压缩打包程序"></a>8.2.1. zip压缩打包程序</h3><ul>
<li><strong>使用</strong><code>**zip**</code><strong>打包文件夹（未加密）：</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/shiyanlou</span><br><span class="line">zip -r -q -o shiyanlou.zip /home/shiyanlou/Desktop</span><br><span class="line"><span class="built_in">du</span> -h shiyanlou.zip</span><br><span class="line">file shiyanlou.zip</span><br></pre></td></tr></table></figure>
<ol>
<li><code>**-r**</code><strong>：表示递归打包包含子目录的全部内容</strong></li>
<li><code>**-q**</code><strong>：表示安静模式，即不向屏幕输出信息</strong></li>
<li><code>**-o**</code><strong>：表示**</strong>覆盖已存在的目标文件而无需确认**</li>
<li><code>du</code>：显示文件或目录的磁盘使用空间</li>
<li><code>-h</code>：表示以人类可读的格式(如K、M、G)显示文件大小</li>
<li><code>file</code>命令：用于确定文件类型</li>
</ol>
<ul>
<li><strong>设置压缩级别：</strong></li>
</ul>
<p>设置压缩级别为<code>9</code>和<code>1</code>，重新打包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zip -r -9 -q -o shiyanlou_9.zip /home/shiyanlou/Desktop -x ~/*.zip</span><br><span class="line">zip -r -1 -q -o shiyanlou_1.zip /home/shiyanlou/Desktop -x ~/*.zip</span><br></pre></td></tr></table></figure>
<p><code>1</code>表示最快压缩但体积大、<code>9</code>表示体积最小但耗时久</p>
<ul>
<li><code>-r</code>：递归压缩，包括子目录。</li>
<li><code>-9</code>：表示使用最高的压缩级别，通常能获得较好的压缩比，但压缩时间可能较长。</li>
<li><code>-q</code>：安静模式，不输出压缩过程的详细信息。</li>
<li><code>-o</code>：覆盖已存在的目标文件而无需确认。</li>
<li><code>/home/shiyanlou/Desktop</code>：要压缩的目录路径。</li>
<li><code>-x ~/*.zip</code>：排除当前用户主目录下（<code>~</code>代表当前用户主目录）所有以<code>.zip</code>结尾的文件，即不将这些已有的压缩文件再次包含在新的压缩包中。</li>
</ul>
<ul>
<li>用 <code>du</code> 命令分别查看默认压缩级别、最低、最高压缩级别及未压缩的文件的大小：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du -h -d 0 *.zip ~ | sort</span><br></pre></td></tr></table></figure>
<ul>
<li><code>du</code>：用于显示文件或目录磁盘使用空间</li>
<li><code>-h</code>：<code>--human-readable</code>以人类可读的格式（如 K、M、G）显示文件大小</li>
<li><code>-d</code>：<code>--max-depth</code>显示所查看文件的深度</li>
</ul>
<ul>
<li><strong>创建加密</strong><code>**zip**</code><strong>包</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zip -r -e -o shiyanlou_encryption.zip /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-e</code>：单词<code>encryption加密</code>的缩写，输入此参数后会提示用户输入两次密码，用于加密压缩包</li>
</ul>
<h3 id="8-2-2-使用unzip命令解压缩zip文件"><a href="#8-2-2-使用unzip命令解压缩zip文件" class="headerlink" title="8.2.2. 使用unzip命令解压缩zip文件"></a>8.2.2. 使用<code>unzip</code>命令解压缩<code>zip</code>文件</h3><ul>
<li>将<code>shiyanlou.zip</code>解压到当前目录：<code>unzip shiyanlou.zip</code></li>
</ul>
<ul>
<li>使用安静模式，将文件解压到指定目录：<code>unzip -q shiyanlou.zip -d ziptest</code></li>
</ul>
<p><code>-d</code>：指定解压缩文件的目标路径，后面跟着<code>ziptest</code>这个存放目录</p>
<p>指定目录不存在，将会自动创建</p>
<ul>
<li>如果不想解压<strong>只是查看压缩包内容：</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip -l shiyanlou.zip <span class="comment"># -l 可以看作list，列出的意思</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指定编码类型：<code>unzip -O GBK 中文压缩文件.zip</code></li>
</ul>
<h2 id="8-3-tar打包工具"><a href="#8-3-tar打包工具" class="headerlink" title="8.3. tar打包工具"></a>8.3. <code>tar</code>打包工具</h2><ul>
<li>“<code>打包文件</code>“与”<code>压缩</code>“概念不同：</li>
</ul>
<p>——打包并没有对文件的大小进行实质性的缩减，而压缩会对文件大小进行缩减</p>
<ul>
<li><code>tar</code>的解压和压缩都是同一个命令，只需参数不同，使用比较方便</li>
</ul>
<h3 id="8-3-1-创建一个-tar-包"><a href="#8-3-1-创建一个-tar-包" class="headerlink" title="8.3.1. 创建一个 tar 包"></a>8.3.1. 创建一个 <code>tar</code> 包</h3><ul>
<li><code>tar -P -cf shiyanlou.tar /home/shiyanlou/Desktop</code></li>
</ul>
<p>作用是将 <code>/home/shiyanlou/Desktop</code> 目录下的文件打包成一个名为 <code>shiyanlou.tar</code> 的归档文件，同时保留绝对路径名（<code>-P</code> 参数的作用）</p>
<ul>
<li><code>-P</code>：<code>Preserve absolute path</code>保留绝对路径【保留绝对路径名进行操作。如果不使用这个参数，在打包时会去除文件的绝对路径信息，只保留相对路径。】</li>
<li><code>-c</code>：<code>create</code>创建，表示创建新的归档文件</li>
<li><code>-f shiyanlou.tar</code>：指定归档文件名称为<code>shiyanlou.tar</code></li>
</ul>
<h3 id="8-3-2-解包一个文件到指定目录（-c）"><a href="#8-3-2-解包一个文件到指定目录（-c）" class="headerlink" title="8.3.2. 解包一个文件到指定目录（-c）"></a>8.3.2. 解包一个文件到指定目录（<code>-c</code>）</h3><p><code>tar -xf shiyanlou.tar -C tardir</code>，用于解压缩名为<code>shiyanlou.tar</code>的归档文件到一个已存在的名为<code>tardir</code>的目录中</p>
<ul>
<li><code>-x</code>：单词<code>extract</code>提取，表示解包操作</li>
<li><code>-f shiyanlou.tar</code>指定要解包的归档文件名称</li>
<li><code>-C tardir</code>表示将解包后的文件放置到名为<code>tardir</code>的目录中，<code>-C</code>是<code>Change to directory</code>的缩写，即切换到指定目录的意思</li>
</ul>
<h3 id="8-3-3-只查看、不解包文件"><a href="#8-3-3-只查看、不解包文件" class="headerlink" title="8.3.3. 只查看、不解包文件"></a>8.3.3. 只查看、不解包文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -tf shiyanlou.tar</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tar</code>：用于创建、提取和列出归档文件的命令</li>
<li><code>-t</code>：<code>table of contents</code>表示列出归档文件中的目录和文件列表信息</li>
<li><code>-f shiyanlou.tar</code>指定要操作的归档文件名称为<code>shiyanlou.tar</code></li>
</ul>
<h3 id="8-3-4-保留文件属性和跟随链接"><a href="#8-3-4-保留文件属性和跟随链接" class="headerlink" title="8.3.4. 保留文件属性和跟随链接"></a>8.3.4. 保留文件属性和跟随链接</h3><p>在进行文件备份时，使用 <code>tar</code>命令可以保留文件的属性和处理链接（包括符号链接或软链接）。</p>
<ol>
<li><strong>保留文件属性</strong>：使用 <code>-p</code> 参数，可以保留文件的权限、时间戳等属性。这样在还原文件时，文件的这些属性也会被保留。</li>
<li><strong>跟随链接</strong>：使用 <code>-h</code> 参数，可以使得 <code>tar</code> 在备份时，备份的是链接指向的源文件，而不是链接本身。这样在还原时，可以正确地恢复出链接。</li>
</ol>
<p><code>tar -c -p -h -f etc.tar /etc</code>创建一个名为 “etc.tar” 的归档文件，其中包含了<code>/etc</code>目录下的内容，同时通过指定<code>/etc</code>，明确了要将这个特定目录下的内容整合到名为 “<code>etc.tar</code>“ 的归档文件中。</p>
<ul>
<li><code>-c</code>：表示创建新的归档文件。</li>
<li><code>-p</code>：保留文件的权限和属性。在打包过程中，确保文件的权限（如读、写、执行权限）以及所有者、所属组等属性与原始文件一致。</li>
<li><code>-h</code>：通常表示跟随符号链接，即如果源目录中有符号链接，将链接所指向的文件内容打包进来，而不是仅仅打包符号链接本身。</li>
<li><code>-f etc.tar</code>：指定归档文件的名称为 “etc.tar”。</li>
</ul>
<h3 id="8-3-5-将-tar-与-gzip-结合使用"><a href="#8-3-5-将-tar-与-gzip-结合使用" class="headerlink" title="8.3.5. 将 tar 与 gzip 结合使用"></a>8.3.5. 将 <code>tar</code> 与 <code>gzip</code> 结合使用</h3><p><code>tar</code>主要用于将多个文件和目录打包成一个归档文件，本身不具备很强的压缩能力，但可以<code>结合</code>其他压缩工具（如 <code>gzip</code>、<code>bizp2</code>、<code>xz</code> 等）进行压缩：</p>
<p>例如，我们这里使用<code>gzip</code>工具创建<code>*.tar.gz</code>文件为例来说明</p>
<ol>
<li>我们只需要在创建<code>tar</code>文件的基础上添加<code>-z</code>参数，使用<code>gzip</code>来压缩文件：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -czf shiyanlou.tar.gz /home/shiyanlou/Desktop</span><br></pre></td></tr></table></figure>
<ul>
<li>这段命令创建了一个名为 <code>shiyanlou.tar.gz</code> 的压缩归档文件，其中包含 <code>/home/shiyanlou/Desktop</code> 目录下的所有文件和子目录。</li>
<li><code>-c</code>：<code>create</code>创建归档文件</li>
<li><code>-z</code>：使用<code>gzip</code>来压缩</li>
<li><code>-f</code>：指定<code>file</code>名称</li>
<li><code>shiyanlou.tar.gz</code>：压缩文件的名称</li>
<li><code>/home/shiyanlou/Desktop</code>：将要压缩归档的文件目录</li>
</ul>
<ol>
<li>解压<code>*.tar.gz</code>文件：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xzf shiyanlou.tar.gz</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>拓展：</strong>若使用其他的压缩工具创建或解压相应文件只需要更改一个参数即可：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>压缩文件格式</strong></th>
<th><strong>参数</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*.tar.gz</code></td>
<td><code>-z</code></td>
</tr>
<tr>
<td><code>*.tar.xz</code></td>
<td><code>-J</code></td>
</tr>
<tr>
<td><code>*tar.bz2</code></td>
<td><code>-j</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="8-4-总结"><a href="#8-4-总结" class="headerlink" title="8.4. 总结"></a>8.4. 总结</h2><ul>
<li><code>zip</code>：</li>
</ul>
<p>打包 ：<code>zip something.zip something</code> （目录请加 -r 参数）</p>
<p>解包：<code>unzip something.zip</code></p>
<p>指定路径：<code>-d</code> 参数</p>
<ul>
<li><code>tar</code>：</li>
</ul>
<p>打包：<code>tar -cf something.tar something</code></p>
<p>解包：<code>tar -xf something.tar</code></p>
<p>指定路径：<code>-C</code> 参数</p>
<h2 id="8-5-作业"><a href="#8-5-作业" class="headerlink" title="8.5. 作业"></a>8.5. 作业</h2><p>创建一个名为 <code>test</code> 的文件，分别用 <code>zip</code>和 <code>tar</code> 打包成压缩包，再解压到 <code>/home/shiyanlou</code> 目录：</p>
<ol>
<li>使用 <code>zip</code> 打包：</li>
</ol>
<ul>
<li><code>zip test.zip test</code>，这将创建一个名为 “<code>test.zip</code>” 的压缩包，包含文件 “<code>test</code>”。</li>
</ul>
<ol>
<li>解压到 <code>/home/shiyanlou</code> 目录：</li>
</ol>
<ul>
<li>首先确保你有对 <code>/home/shiyanlou</code> 目录的写入权限。</li>
</ul>
<ol>
<li>使用 <code>tar</code> 打包：</li>
</ol>
<ul>
<li><code>tar -cf test.tar test</code>，这将创建一个名为 “<code>test.tar</code>” 的归档文件，包含文件 “<code>test</code>”。</li>
</ul>
<ol>
<li>解压到 <code>/home/shiyanlou</code> 目录：</li>
</ol>
<ul>
<li><code>tar -xf test.tar -C /home/shiyanlou</code>，这将把 “<code>test.tar</code>” 中的文件解压到 <code>/home/shiyanlou</code> 目录。</li>
</ul>
<h1 id="9-文件系统操作与磁盘管理"><a href="#9-文件系统操作与磁盘管理" class="headerlink" title="9. 文件系统操作与磁盘管理"></a>9. 文件系统操作与磁盘管理</h1><h2 id="9-1-基本操作"><a href="#9-1-基本操作" class="headerlink" title="9.1. 基本操作"></a>9.1. 基本操作</h2><h3 id="9-1-1-查看磁盘和目录容量"><a href="#9-1-1-查看磁盘和目录容量" class="headerlink" title="9.1.1. 查看磁盘和目录容量"></a>9.1.1. 查看磁盘和目录容量</h3><ul>
<li><p>使用<code>df</code>命令查看磁盘的容量：<code>df</code></p>
</li>
<li><p>可选：<code>-h</code>参数，以人类可以看懂的方式显示，<code>df -h</code></p>
</li>
</ul>
<ul>
<li><p>使用<code>du</code>命令查看目录的容量</p>
</li>
<li><p>可选：<code>-h</code>参数</p>
</li>
<li>可选：<code>-d</code>参数，指定查看目录的深度，例如：<code>du -h -d 0 ~</code>查看1级目录的信息；<code>du -h -d 1 ~</code>查看2级目录的深度</li>
<li>可选：<code>-a</code>同<code>--all</code>显示目录中所有文件的大小</li>
<li>可选：<code>-s</code>同<code>--summarize</code>仅显示总计，只列出最后加总的值</li>
</ul>
<h2 id="9-2-简单的磁盘管理"><a href="#9-2-简单的磁盘管理" class="headerlink" title="9.2. 简单的磁盘管理"></a>9.2. 简单的磁盘管理</h2><p><strong>下面涉及的命令具有一定的危险性，操作不当可能会丢失你的个人数据，初学者建议在虚拟环境中进行操作。</strong></p>
<h3 id="9-2-1-创建虚拟磁盘"><a href="#9-2-1-创建虚拟磁盘" class="headerlink" title="9.2.1. 创建虚拟磁盘"></a>9.2.1. 创建虚拟磁盘</h3><p><code>dd</code>：是一个强大但相对复杂的工具，主要用于数据转换和复制，常见用于<strong>备份和恢复磁盘或分区、创建特定大小的文件、转换数据格式。</strong></p>
<ul>
<li>从<strong>标准输入读入用户的输入</strong>到<strong>标准输出</strong>或者<strong>一个文件</strong>中：</li>
</ul>
<ol>
<li><code>dd of=test bs=10 count=1</code> #输出到一个文件中，可以使用<code>du -b test</code>查看文件内存情况</li>
</ol>
<p>(或<code>dd if=/dev/stdin of=test bs=10 count=1</code>)</p>
<ul>
<li><code>dd</code>：数据复制和转换命令。</li>
<li><code>if=/dev/stdin</code>：指定输入源为标准输入。这意味着你可以从键盘输入数据或者通过管道将其他命令的输出作为输入。</li>
<li><code>of=test</code>：指定输出文件为 “test”。</li>
<li><code>bs=10</code>：设置块大小为 10 字节。</li>
<li><code>count=1</code>：表示复制 1 个块。</li>
</ul>
<ol>
<li><code>dd if=/dev/stdin of=/dev/stdout bs=10 count=1``#输出到标准输出</code></li>
</ol>
<ul>
<li><strong>为什么要设置块大小和复制块的个数？</strong></li>
</ul>
<ol>
<li><strong>块大小（</strong><code>**bs**</code><strong>）</strong>：</li>
</ol>
<ul>
<li>块大小决定了每次读写操作的数据量。选择合适的块大小可以影响数据传输的效率。</li>
</ul>
<ol>
<li><strong>复制块的个数（</strong><code>**count**</code><strong>）</strong>：</li>
</ol>
<ul>
<li>通过设置 <code>count</code>，可以避免复制不必要的数据，节省时间和资源。例如，如果你只需要复制文件的前几个块，可以设置一个较小的 <code>count</code> 值。</li>
</ul>
<ul>
<li>将输出的<strong>英文字符</strong>转换为<strong>大写</strong>再写入文件：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/dev/stdin of=test bs=10 count=1 conv=ucase</span><br></pre></td></tr></table></figure>
<h3 id="9-2-2-使用dd命令创建虚拟镜像文件"><a href="#9-2-2-使用dd命令创建虚拟镜像文件" class="headerlink" title="9.2.2. 使用dd命令创建虚拟镜像文件"></a>9.2.2. 使用<code>dd</code>命令创建虚拟镜像文件</h3><p>从<code>/dev/zero</code>设备创建一个容量为<code>256M</code>的空文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=virtual.img bs=1M count=256</span><br></pre></td></tr></table></figure>
<p>查看刚刚创建的文件大小情况：<code>du -h virtual.img</code></p>
<p><img src="/img/创建虚拟镜像.png" alt="img"></p>
<h3 id="9-2-3-使用mkfs命令格式化磁盘"><a href="#9-2-3-使用mkfs命令格式化磁盘" class="headerlink" title="9.2.3. 使用mkfs命令格式化磁盘"></a>9.2.3. 使用<code>mkfs</code>命令格式化磁盘</h3><p>在命令行输入 <code>sudo mkfs</code> 然后按下 <code>&lt;Tab&gt;</code> 键，你可以看到很多个以 mkfs 为前缀的命令，这些不同的后缀其实就是表示着不同的文件系统，可以用 mkfs 格式化成的文件系统</p>
<p><img src="/img/mkfs.png" alt="img"></p>
<p>我们这里输入<code>sudo mkfs.ext4 virtual.img</code></p>
<ul>
<li><code>mkfs.ext4</code>：是用于创建 ext4 文件系统的命令工具。“<code>mkfs</code>” 是 “<code>make file system</code>” 的缩写，而 “ext4” 是一种常见的 Linux 文件系统类型，具有较好的性能和稳定性。</li>
<li><code>virtual.img</code>：指定要创建文件系统的目标文件。在这里，就是之前通过<code>dd</code>命令创建的名为 “virtual.img” 的文件。</li>
</ul>
<p>想知道 Linux 支持哪些文件系统你可以输入 <code>ls -l /lib/modules/$(uname -r)/kernel/fs</code> 来查看</p>
<h3 id="9-2-4-使用mount命令挂载磁盘到目录树"><a href="#9-2-4-使用mount命令挂载磁盘到目录树" class="headerlink" title="9.2.4. 使用mount命令挂载磁盘到目录树"></a>9.2.4. 使用<code>mount</code>命令挂载磁盘到目录树</h3><p>在Linux或UNIX系统中，如果想要打开一个文件，在这之前，包含这个文件的文件系统必须先进行挂载的动作，系统的根目录是一直处于挂载状态的，这样系统才能正常启动和运行。</p>
<p>但对于大多常见的存储设备和文件系统分区，在系统启动时，会通过配置文件（如<code>/etc/fstab</code>）<strong>自动挂载，无须手动挂载。</strong></p>
<ul>
<li>但是对于一些可移动存储设备（如U盘、移动硬盘等），可能在使用时需要手动挂载</li>
</ul>
<ul>
<li>使用<code>mount</code>来查看主机已经挂载的文件系统：<code>sudo mount</code></li>
</ul>
<p><img src="/img/mkf.png" alt="img"></p>
<p> 其中，输出结果中的每一行表示一个设备或虚拟设备，<strong>每一行最前面</strong>是<strong>设备名</strong>，然后<code>on</code>后面是<strong>挂载点，</strong><code>type</code>后面表示文件系统类型，然后后面是<strong>挂载选项（</strong>比如可以在挂载时设定以只读方式挂载等等<strong>）</strong></p>
<ul>
<li>挂载真正的磁盘到目录树：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount`命令的一般格式：`mount [options][source][directory]</span><br></pre></td></tr></table></figure>
<p>一些常用操作：<code>**mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]**</code></p>
<p>示例：<code>mount -o loop --ro virtual.img /mnt</code></p>
<ul>
<li><code>mount</code>：是用于挂载文件系统的命令。</li>
<li><code>-o loop</code>：表示使用环回设备挂载。环回设备允许将一个文件当作一个块设备来使用，就好像它是一个物理存储设备一样。在这种情况下，“<code>virtual.img</code>” 这个文件被当作一个存储设备进行挂载。</li>
<li><code>-t ext4</code>：指定要挂载的文件系统类型为<code>ext4</code>。这告诉系统 “<code>virtual.img</code>” 文件中包含的是 <code>ext4</code> 文件系统。</li>
<li><code>virtual.img</code>：是要<strong>挂载的文件的名称</strong>。</li>
<li><code>/mnt</code>：是<strong>挂载点，</strong>即文件系统被挂载后在文件系统目录树中的位置。挂载后，通过访问 “/mnt” 目录，就可以访问 “<code>virtual.img</code>” 文件中所包含的 ext4 文件系统中的内容。</li>
</ul>
<h3 id="9-2-5-使用umount命令卸载已挂载磁盘"><a href="#9-2-5-使用umount命令卸载已挂载磁盘" class="headerlink" title="9.2.5. 使用umount命令卸载已挂载磁盘"></a>9.2.5. 使用umount命令卸载已挂载磁盘</h3><p>命令格式<code>sudo umount 已挂载设备名或者挂载点</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo umount /mnt</span><br></pre></td></tr></table></figure>
<h3 id="9-2-6-使用fdisk为磁盘分区"><a href="#9-2-6-使用fdisk为磁盘分区" class="headerlink" title="9.2.6. 使用fdisk为磁盘分区"></a>9.2.6. 使用fdisk为磁盘分区</h3><p>在 Linux 系统中，可以使用 <code>fdisk</code> 命令为磁盘进行分区，以下是具体步骤：</p>
<p><strong>一、查看磁盘设备</strong></p>
<p>首先，使用 <code>lsblk</code> 或 <code>fdisk -l</code> 命令查看系统中的磁盘设备。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure>
<p>这将列出系统中的所有块设备，包括硬盘、分区和其他存储设备。确定你要进行分区的磁盘设备名称，通常以 <code>/dev/sdX</code> 的形式表示，其中 <code>X</code> 是一个字母，如 <code>/dev/sda</code>、<code>/dev/sdb</code> 等。</p>
<p><strong>二、运行</strong> <code>fdisk</code> <strong>命令</strong></p>
<p>以管理员权限运行 <code>fdisk</code> 命令，并指定要分区的磁盘设备：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo fdisk /dev/sdX</span><br></pre></td></tr></table></figure>
<p>这里的 <code>/dev/sdX</code> 是你要分区的磁盘设备名称。</p>
<p><strong>三、进入</strong> <code>fdisk</code> <strong>交互模式</strong></p>
<p>运行上述命令后，你将进入 <code>fdisk</code> 的交互模式。在这个模式下，你可以输入各种命令来进行分区操作。</p>
<p><strong>四、常用命令</strong></p>
<ol>
<li><code>p</code>：打印当前磁盘的分区表，显示已有的分区信息。</li>
<li><code>n</code>：创建新分区。选择 <code>n</code> 后，系统会提示你选择分区类型（主分区或扩展分区），然后输入分区的起始和结束扇区位置。通常可以接受默认值来创建连续的分区。</li>
<li><code>d</code>：删除分区。选择 <code>d</code> 后，系统会提示你选择要删除的分区编号。</li>
<li><code>t</code>：更改分区类型代码。可以使用这个命令将分区类型更改为特定的文件系统类型，如 Linux 文件系统（类型代码 83）、交换分区（类型代码 82）等。</li>
<li><code>w</code>：保存分区表并退出。在完成分区操作后，输入 <code>w</code> 保存更改并退出 <code>fdisk</code>。</li>
</ol>
<p><strong>五、注意事项</strong></p>
<ol>
<li>在进行分区操作之前，一定要备份重要数据，因为分区操作可能会导致数据丢失。</li>
<li>仔细选择分区的大小和类型，确保满足你的系统需求。</li>
<li>如果不确定如何操作，不要随意进行分区，可以先在测试环境中进行练习，或者参考更多的文档和教程。</li>
</ol>
<p>例如，以下是一个简单的分区操作示例：</p>
<ol>
<li>运行 <code>sudo fdisk /dev/sda</code> 进入交互模式。</li>
<li>输入 <code>p</code> 查看当前分区表。</li>
<li>输入 <code>n</code> 创建新分区，按照提示选择分区类型和输入分区大小。</li>
<li>输入 <code>w</code> 保存分区表并退出。</li>
</ol>
<p>完成分区操作后，新的分区可能需要进行格式化才能使用。可以使用 <code>mkfs</code> 命令（如 <code>mkfs.ext4 /dev/sda1</code>）对新分区进行格式化，具体命令取决于你要使用的文件系统类型。</p>
<h3 id="9-2-7-使用loseup命令建立镜像与回环设备的关联"><a href="#9-2-7-使用loseup命令建立镜像与回环设备的关联" class="headerlink" title="9.2.7. 使用loseup命令建立镜像与回环设备的关联"></a>9.2.7. 使用loseup命令建立镜像与回环设备的关联</h3><ul>
<li><p><code>losetup</code> 命令用于将虚拟磁盘镜像文件与一个回环设备（loop device）关联起来。这样，操作系统就可以像对待一个真实的物理存储设备一样对待这个虚拟磁盘镜像文件。</p>
</li>
<li><p>将名为 “<code>virtual.img</code>” 的文件关联到 <code>/dev/loop0</code> 这个回环设备上：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo losetup /dev/loop0 virtual.img</span><br></pre></td></tr></table></figure>
<ul>
<li><code>losetup</code>：是用于设置和控制回环设备的命令。</li>
<li><code>/dev/loop0</code>：指定要关联的回环设备名称。回环设备允许将一个文件当作一个块设备来使用，就像一个物理存储设备一样。</li>
<li><p><code>virtual.img</code>：是要关联的文件的名称。在这个例子中，就是名为 “virtual.img” 的文件。</p>
</li>
<li><p>解除设备关联：<code>sudo losetup -d /dev/loop0</code></p>
</li>
</ul>
<ul>
<li><p><strong>使用</strong> <code>**kpartx**</code> <strong>命令映射虚拟磁盘分区</strong></p>
</li>
<li><p>如果虚拟磁盘镜像文件中包含分区，<code>kpartx</code> 命令可以将这些分区映射为设备节点，以便我们可以像访问真实硬盘的分区一样访问虚拟磁盘的分区。</p>
</li>
</ul>
<p>安装<code>kpartx</code>工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装kpartx工具</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install kpartx</span><br><span class="line"><span class="comment">#建立映射</span></span><br><span class="line"><span class="built_in">sudo</span> kpartx -av /dev/loop0</span><br><span class="line"></span><br><span class="line"><span class="comment">#取消映射</span></span><br><span class="line"><span class="built_in">sudo</span> kpartx -dv /dev/loop0</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-a</code>：表示自动添加分区映射。它会扫描指定的设备（这里是 <code>/dev/loop0</code>），查找其中的分区，并将这些分区映射为设备节点，以便可以像访问真实硬盘分区一样访问虚拟磁盘中的分区。</li>
<li><code>-v</code>：表示显示详细信息。在执行命令时，会输出关于添加的分区映射的详细信息，包括分区的设备节点名称、大小等。</li>
</ul>
<p><img src="/img/虚拟磁盘分区.png" alt="img"></p>
<ul>
<li><p><strong>格式化分区</strong></p>
</li>
<li><p>在使用虚拟磁盘分区之前，通常需要对其进行格式化，以创建一个特定的文件系统，这样才能在分区上存储文件。</p>
</li>
</ul>
<p>我们将其全部格式化为<code>ext4</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mkfs.ext4 -q /dev/mapper/loop0p1</span><br><span class="line"><span class="built_in">sudo</span> mkfs.ext4 -q /dev/mapper/loop0p5</span><br><span class="line"><span class="built_in">sudo</span> mkfs.ext4 -q /dev/mapper/loop0p6</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>在</strong><code>**/media**</code><strong>目录下新建四个空目录用于挂载虚拟磁盘</strong></p>
</li>
<li><p><strong>新建目录的作用：</strong></p>
</li>
</ul>
<p><strong>主要是为了</strong>明确挂载点：创建专门的目录作为挂载点可以使虚拟磁盘的挂载位置更加清晰和明确。这样在系统中可以很容易地识别出哪些目录是用于挂载虚拟磁盘分区的，便于管理和维护。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /media/virtualdisk_&#123;1..3&#125;</span><br><span class="line"># 挂载磁盘分区</span><br><span class="line">sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1</span><br><span class="line">sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2</span><br><span class="line">sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3</span><br><span class="line"></span><br><span class="line"># 卸载磁盘分区</span><br><span class="line">sudo umount /dev/mapper/loop0p1</span><br><span class="line">sudo umount /dev/mapper/loop0p5</span><br><span class="line">sudo umount /dev/mapper/loop0p6</span><br></pre></td></tr></table></figure>
<p>可以使用<code>df -h</code>查看此时文件系统状态</p>
<h2 id="9-3-作业"><a href="#9-3-作业" class="headerlink" title="9.3. 作业"></a>9.3. 作业</h2><p>小明在管理服务器的时候发现空间不足了，他找到了一个目录，这个目录占用的空间异常的大，他需要找到这个目录中占用最大的前 10 个文件，但是这个目录下面的内容太多了，或许一条命令就能够帮助到他，这条命令该怎么写呢？</p>
<p>简而言之：找出当前目录下面占用最大的前十个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -maxdepth 1 -type f -exec du -h &#123;&#125; + | sort -rh | head -n 10</span><br></pre></td></tr></table></figure>
<ul>
<li><code>find .</code>：在当前目录下查找文件和目录。</li>
<li><code>-maxdepth 1</code>：限制查找深度为当前目录，不进入子目录。</li>
<li><code>-type f</code>：只查找文件，不包括目录。</li>
<li><code>-exec du -h &#123;&#125; +</code>：对找到的每个文件执行 <code>du -h</code> 命令，<code>-h</code> 选项表示以易读的格式（如 K、M、G）显示文件大小。</li>
<li><code>sort -rh</code>：将 <code>du</code> 命令的输出结果按照人类可读的格式（<code>-h</code>）进行排序，<code>-r</code> 表示逆序（从大到小），<code>-h</code> 表示按照人类可读的数字大小排序。</li>
<li><code>head -n 10</code>：从排序后的结果中取出前10行，即最大的10个文件。</li>
</ul>
<h1 id="10-Linux下的帮助命令"><a href="#10-Linux下的帮助命令" class="headerlink" title="10. Linux下的帮助命令"></a>10. Linux下的帮助命令</h1><h2 id="10-1-内建命令与外部命令"><a href="#10-1-内建命令与外部命令" class="headerlink" title="10.1. 内建命令与外部命令"></a>10.1. 内建命令与外部命令</h2><ul>
<li><strong>内建命令</strong>：是shell自带的天赋技能，是<code>shell</code>程序的一部分，包含一些简单的Linux系统命令，如<code>cd</code>、<code>echo</code>、<code>exit</code>、<code>history</code>、<code>pwd</code></li>
<li><strong>外部命令：</strong>是后天得来的附加技能，通常功能更加强大和复杂，不依赖特定的<code>shell</code>环境，可以不同的shell中使用，如<code>ls</code>、<code>grep</code>、<code>cp</code>、<code>mv</code>、<code>vi</code>，通常放在<code>/bin</code>、<code>/usr/bin</code>、<code>/sbin</code>、<code>usr/sbin</code>等等</li>
<li><strong>如何区分内建命令和外部命令？</strong></li>
</ul>
<p>使用 type 命令可以区分命令是内建的还是外部的</p>
<p><img src="/img/内部外部命令.png" alt="img"></p>
<h2 id="10-2-帮助命令的使用"><a href="#10-2-帮助命令的使用" class="headerlink" title="10.2. 帮助命令的使用"></a>10.2. 帮助命令的使用</h2><h3 id="10-2-1-help-命令"><a href="#10-2-1-help-命令" class="headerlink" title="10.2.1. help 命令"></a>10.2.1. help 命令</h3><p>本实验环境是 zsh，而 zsh 中内置并没有 help 命令，我们可以进入 bash 中，在 bash 中内置有该命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br></pre></td></tr></table></figure>
<ul>
<li><code>help</code>命令只能用于显示内建命令的帮助信息：</li>
</ul>
<p>若输入<code>help ls</code>则显示没有找到与<code>ls</code>匹配的主题，<strong>但可以输入</strong><code>**ls --help**</code>命令，外部命令基本都有一个参数<code>--help</code>参数</p>
<p><img src="/img/help.png" alt="img"> </p>
<h3 id="10-2-2-man-命令"><a href="#10-2-2-man-命令" class="headerlink" title="10.2.2. man 命令"></a>10.2.2. man 命令</h3><ul>
<li>通常情况下，<code>man</code> 命令（manual 的缩写）提供的文档比 <code>help</code> 命令更加详细</li>
</ul>
<p>例如：输入<code>man ls</code>命令：</p>
<p><img src="/img/man.png" alt="img"></p>
<p>最左上角显示”LS(1)”，LS表示手册名称，而(1)表示位于第一章：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>章节数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1</code></td>
<td>Standard commands （标准命令）</td>
</tr>
<tr>
<td><code>2</code></td>
<td>System calls （系统调用）</td>
</tr>
<tr>
<td><code>3</code></td>
<td>Library functions （库函数）</td>
</tr>
<tr>
<td><code>4</code></td>
<td>Special devices （设备说明）</td>
</tr>
<tr>
<td><code>5</code></td>
<td>File formats （文件格式）</td>
</tr>
<tr>
<td><code>6</code></td>
<td>Games and toys （游戏和娱乐）</td>
</tr>
<tr>
<td><code>7</code></td>
<td>Miscellaneous （杂项）</td>
</tr>
<tr>
<td><code>8</code></td>
<td>Administrative Commands （管理员命令）</td>
</tr>
<tr>
<td><code>9</code></td>
<td>其他（Linux 特定的）， 用来存放内核例行程序的文档。</td>
</tr>
</tbody>
</table>
</div>
<p>通过 <code>pgup</code> 与 <code>pgdn</code> 或者上下键来上下翻看，可以按 <code>q</code> 退出当前页面</p>
<h3 id="10-2-3-info-命令"><a href="#10-2-3-info-命令" class="headerlink" title="10.2.3. info 命令"></a>10.2.3. info 命令</h3><p>要是你觉得 man 显示的信息都还不够，满足不了你的需求，那试试 info 命令，注意实验楼的环境中没有安装 info，可以手动安装，安装和操作步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 info</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install info</span><br><span class="line"><span class="comment"># 查看 ls 命令的 info</span></span><br><span class="line">info <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>
<h1 id="11-Linux-任务计划-crontab"><a href="#11-Linux-任务计划-crontab" class="headerlink" title="11. Linux 任务计划 crontab"></a>11. Linux 任务计划 crontab</h1><h2 id="11-1-crontab-的使用"><a href="#11-1-crontab-的使用" class="headerlink" title="11.1. crontab 的使用"></a>11.1. crontab 的使用</h2><h3 id="11-1-1-crontab-简介"><a href="#11-1-1-crontab-简介" class="headerlink" title="11.1.1. crontab 简介"></a>11.1.1. crontab 简介</h3><ul>
<li><code>crontab</code>命令常见于<code>Unix</code>和类<code>Unix</code>的操作系统中（<code>Linux</code>属于类<code>Unix</code>操作系统），用于<strong>设置周期性被执行的指令，</strong>可以在固定间隔时间执行指定的系统指令或<code>shell</code>脚本。</li>
</ul>
<ol>
<li><code>crontab</code>命令从输入设备读取指令，并将其存放于<code>crontab</code>文件中，以供之后读取和执行。</li>
<li><code>crond</code>为<code>crontab</code>存储指令的守护进程，<code>crond</code>常常在后台运行，每一分钟检查一次是否有预定的作业需要执行</li>
</ol>
<ul>
<li><code>crontab</code>的格式：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure>
<h3 id="11-1-2-crontab-准备"><a href="#11-1-2-crontab-准备" class="headerlink" title="11.1.2. crontab 准备"></a>11.1.2. crontab 准备</h3><p>我们首先需要启动<code>rsyslog</code>，以便我们可以通过日志中的信息来了解我们的任务是否真正被执行了（在本地的<code>Ubuntu</code>会默认自行启动而不需要手动启动）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install -y rsyslog</span><br><span class="line"><span class="built_in">sudo</span> service rsyslog start</span><br></pre></td></tr></table></figure>
<p>在本实验环境中 <code>crontab</code> 也是不被默认启动的，同时不能在后台由<code>upstart</code>来管理，所以需要我们来启动它:</p>
<p><strong>启动</strong><code>**cron**</code><strong>：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> cron －f &amp;</span><br></pre></td></tr></table></figure>
<h3 id="11-1-3-crontab-使用"><a href="#11-1-3-crontab-使用" class="headerlink" title="11.1.3. crontab 使用"></a>11.1.3. crontab 使用</h3><ul>
<li><code>**crontab -e**</code><strong>：添加一个计划任务</strong></li>
</ul>
<p>接着选择2 <code>vim</code>编辑器即可：<img src="/img/crontab.png" alt="img"></p>
<p>在文档的最后一排加上：</p>
<hr>
<p><code>* * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)</code>，该任务是每分钟我们会在<code>/home/shiyanlou</code>目录下创建一个以当前的年月日时分秒为名字的空白文件。</p>
<ul>
<li>第一个字段（0）：分钟（0 - 59）</li>
<li>第二个字段（3）：小时（0 - 23）</li>
<li>第三个字段（*）：日期（1 - 31）</li>
<li>第四个字段（*）：月份（1 - 12）</li>
<li>第五个字段（*）：星期几（0 - 7，其中0和7都表示星期日）</li>
</ul>
<p>特殊字符的含义如下：</p>
<ul>
<li><code>*</code>：表示任何值，即在任何分钟、任何小时、任何日期、任何月份、任何星期几都会执行。</li>
<li><code>-</code>：表示一个范围，例如 <code>1-5</code> 表示从1到5。</li>
<li><code>,</code>：表示一个列表，例如 <code>1,2,5</code> 表示1、2和5。</li>
<li><code>/</code>：表示起始时间开始，每隔一定时间执行一次，例如 <code>0/15</code> 在小时字段中表示每小时的第0分钟和15分钟。</li>
</ul>
<p><img src="/img/crontab1.png" alt="img"></p>
<p><strong>注意：</strong></p>
<p>“ <code>%</code> ” 在 <code>crontab</code> 文件中，有结束命令行、换行、重定向的作用，前面加 ” <code>\</code> ” 符号转义，否则，“ <code>%</code> ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。</p>
<ul>
<li>可以通过<code>crontab -l</code>查看我们添加了哪些任务</li>
</ul>
<p><img src="crontab11.png" alt="img"></p>
<ul>
<li><p><code>ps aux | grep cron</code>【或者使用<code>pgrep cron</code>命令】：查看<code>cron</code>的守护进程是否启动，因为如果没有启动<code>cron</code>守护进程，根本不会监测和执行任务</p>
</li>
<li><p><code>ps aux</code> 是一个常用的命令组合，用于列出系统中所有的进程。</p>
</li>
<li><code>ps</code> 命令用于显示当前系统中的进程状态。</li>
<li><p><code>aux</code> 是 <code>ps</code> 命令的参数组合，其中：</p>
</li>
<li><p><code>a</code> 表示显示所有终端的进程。</p>
</li>
<li><code>u</code> 表示以用户为主的格式显示。</li>
<li><p><code>x</code> 表示显示没有控制终端的进程。</p>
</li>
<li><p><code>grep cron</code> 是对 <code>ps aux</code> 的输出结果进行过滤，只显示包含 <code>cron</code> 字符串的行。</p>
</li>
<li>这种方式会显示所有包含 <code>cron</code> 字符串的进程，可能包括 <code>crontab</code>、<code>crond</code> 等与 <code>cron</code> 相关的进程，也可能包括其他不相关的进程，只要它们的命令行中包含 <code>cron</code> 字符串。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>如果你只需要查看与 <code>cron</code> 相关的进程的<strong>详细信息</strong>，可以使用 <code>ps aux | grep cron</code>。</li>
<li>如果你只需要获取与 <code>cron</code> 相关的进程的 <strong>PID</strong>，可以使用 <code>pgrep cron</code>。</li>
</ul>
<ul>
<li><p>查看到执行任务命令之后在日志中的信息反馈：<code>sudo tail -f /var/log/syslog</code></p>
</li>
<li><p><code>tail</code>：是一个命令行工具，用于显示文件的最后几行内容。</p>
</li>
<li><code>-f</code>：是 <code>tail</code> 命令的一个选项，表示“follow”，即<strong>持续监控文件的新增内容</strong>。</li>
<li><code>/var/log/syslog</code>：是系统日志文件的路径，记录了系统运行过程中的各种信息，包括系统启动、程序运行、错误信息等。</li>
</ul>
<p>当你执行这个命令时，它会显示 <code>/var/log/syslog</code> 文件末尾的内容，并持续显示新添加到文件的内容。这对于实时监控系统活动非常有用</p>
<p><img src="/img/信息反馈.png" alt="img"></p>
<p><img src="/img/crontabr.png" alt="img"></p>
<h2 id="11-2-crontab-的深入"><a href="#11-2-crontab-的深入" class="headerlink" title="11.2. crontab 的深入"></a>11.2. crontab 的深入</h2><p>当用户在Linux系统中使用<code>crontab -e</code>命令来编辑或添加计划任务（也称为<code>cron</code>作业）时，系统会在<code>/var/spool/cron/crontabs</code>这个目录下为该用户创建一个专属的任务文档。</p>
<p>如果是系统级别的定时任务，需要 root 权限执行的任务，只需要使用 <code>sudo</code> 编辑 <code>/etc/crontab</code> 文件就可以，在<code>/etc</code>目录下，与<code>cron</code>相关的目录有下面几个：</p>
<ul>
<li>每个目录的作用：</li>
</ul>
<ol>
<li><code>/etc/cron.daily</code>，目录下的脚本会每天执行一次，在每天的 6 点 25 分时运行；</li>
<li><code>/etc/cron.hourly</code>，目录下的脚本会每个小时执行一次，在每小时的 17 分钟时运行；</li>
<li><code>/etc/cron.monthly</code>，目录下的脚本会每月执行一次，在每月 1 号的 6 点 52 分时运行；</li>
<li><code>/etc/cron.weekly</code>，目录下的脚本会每周执行一次，在每周第七天的 6 点 47 分时运行；</li>
</ol>
<p>系统默认执行时间可以根据需求进行修改。</p>
<p><code>cron</code> 服务监测时间最小单位是分钟，所以 <code>cron</code> 会每分钟去读取一次 <code>/etc/crontab</code> 与 <code>/var/spool/cron/crontabs</code> 里面的內容</p>
<h1 id="12-挑战：备份日志"><a href="#12-挑战：备份日志" class="headerlink" title="12. 挑战：备份日志"></a>12. 挑战：备份日志</h1><p>小明是一个服务器管理员，他需要每天备份论坛数据（这里我们用 <code>alternatives.log</code> 日志替代），备份当天的日志并删除之前的日志。而且备份之后文件名是 <code>年-月-日</code> 的格式。<code>alternatives.log</code> 在 <code>/var/log/</code> 下面。</p>
<p><strong>目标：</strong></p>
<ol>
<li>为 <code>shiyanlou</code> 用户添加计划任务</li>
<li>每天凌晨 3 点的时候定时备份 <code>alternatives.log</code> 到 <code>/home/shiyanlou/tmp/</code> 目录</li>
<li>命名格式为 <code>年-月-日</code>，比如今天是 2017 年 4 月 1 日，那么文件名为 <code>2017-04-01</code></li>
</ol>
<p><strong>提示语：</strong></p>
<ul>
<li>date</li>
<li>crontab</li>
<li>cp 命令</li>
<li>用一条命令写在 crontab 里面即可，不用写脚本</li>
</ul>
<p>注意 crontab 的计划任务设定的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -e 表示为当前用户添加计划任务</span><br><span class="line">sudo crontab -e 表示为root用户添加计划任务</span><br></pre></td></tr></table></figure>
<p>注意使用下面的命令启动 crontab：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> cron －f &amp;</span><br></pre></td></tr></table></figure>
<p><strong>参考答案：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> cron -f &amp;</span><br><span class="line">crontab -e <span class="comment"># 添加</span></span><br><span class="line">0 3 * * * <span class="built_in">sudo</span> <span class="built_in">rm</span> /home/shiyanlou/tmp/*  <span class="comment">#最后面的&quot;*&quot;是通配符，匹配所有文件和目录</span></span><br><span class="line">0 3 * * * <span class="built_in">sudo</span> <span class="built_in">cp</span> /var/log/alternatives.log /home/shiyanlou/tmp/$(<span class="built_in">date</span> +\%Y-\%m-\%d)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$</code> 符号用于命令替换（command substitution）。命令替换允许在命令中嵌入另一个命令，并将其输出作为参数传递给外部命令，<code>$(date +\%Y-\%m-\%d)</code> 会在运行时被替换成当前日期</li>
<li>这个命令会以超级用户权限将 <code>/var/log/alternatives.log</code> 文件复制到 <code>/home/shiyanlou/tmp/</code> 目录，并将其命名为 <code>****-**-**</code>日期。</li>
</ul>
<h1 id="13-命令执行顺序控制与管道"><a href="#13-命令执行顺序控制与管道" class="headerlink" title="13. 命令执行顺序控制与管道"></a>13. 命令执行顺序控制与管道</h1><h2 id="13-1-命令执行顺序的控制"><a href="#13-1-命令执行顺序的控制" class="headerlink" title="13.1. 命令执行顺序的控制"></a>13.1. 命令执行顺序的控制</h2><ul>
<li>有时我们在终端输入一条，有时一次输入多条命令，执行过程是如何呢？</li>
</ul>
<h3 id="13-1-1-顺序执行多条命令"><a href="#13-1-1-顺序执行多条命令" class="headerlink" title="13.1.1. 顺序执行多条命令"></a>13.1.1. 顺序执行多条命令</h3><ul>
<li>简单的顺序执行你可以使用 <code>;</code> 来完成</li>
</ul>
<p>比如：有如下一系列操作，需要逐个输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install some-tool</span><br><span class="line">some-tool</span><br></pre></td></tr></table></figure>
<p>此时可以使用<code>;</code>一次性执行完：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get update;sudo apt-get install some-tool;some-tool</span><br></pre></td></tr></table></figure>
<h3 id="13-1-2-有选择的执行命令"><a href="#13-1-2-有选择的执行命令" class="headerlink" title="13.1.2. 有选择的执行命令"></a>13.1.2. 有选择的执行命令</h3><p>有时候一连串的命令，后面的命令执行<strong>依赖前面执行成功的命令</strong>，但是如果前面<strong>执行不成功</strong>，就会花很长时间，最终得到错误结果</p>
<ul>
<li>当使用 “<code>&amp;&amp;</code>” 连接多个命令时，只有在前面的命令执行成功（即返回值为<code>0</code>）时，后面的命令才会被执行；如果前面的命令执行失败（返回值非 <code>0</code>），则后面的命令不会被执行。</li>
<li>“<code>||</code>” 表示逻辑或。当使用 “<code>||</code>” 连接两个或多个命令时，只有当前面的命令执行失败（即返回值非 <code>0</code>）时，后面的命令才会被执行。如果前面的命令执行成功（返回值为<code>0</code>），则后面的命令不会被执行。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>echo $?</code>：这命令用于显示上一条命令的错误状态码，通常<code>0</code>表示命令执行成功，非<code>0</code>值表示命令执行出现了某种错误</p>
</li>
<li><p><code>&gt;/dev/null</code>” 表示将查找结果重定向到 “<code>/dev/null</code>”，即丢弃输出，不显示在终端上</p>
</li>
<li>执行情况：若<code>cowsay</code>命令存在，输出<code>not exist</code>，若<code>cowsay</code>命令不存在，输出<code>exist</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> cowsay&gt;/dev/null || <span class="built_in">echo</span> <span class="string">&quot;exist&quot;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;not exist&quot;</span></span><br></pre></td></tr></table></figure>
<p>若 “<code>cowsay</code>” 命令不存在，输出 “<code>exist</code>”；若 “<code>cowsay</code>” 命令存在，输出 “<code>not exist</code>”。</p>
<h2 id="13-2-管道"><a href="#13-2-管道" class="headerlink" title="13.2. 管道"></a>13.2. 管道</h2><ol>
<li><strong>管道是一种通信机制</strong>：管道用于进程间的通信，也可以通过网络套接字（socket）进行网络通信。</li>
<li><strong>管道的表现形式</strong>：管道允许将一个进程的输出（stdout）直接作为另一个进程的输入（stdin）。</li>
<li><strong>管道的分类</strong>：</li>
</ol>
<ul>
<li><strong>匿名管道</strong>：在命令行中使用，通过 | 分隔符表示。常用于过滤程序，如 <code>grep</code>、<code>sort</code> 等。</li>
<li><strong>具名管道</strong>：有名字的管道，通常在源程序中使用，通过系统调用创建。</li>
</ul>
<ol>
<li><strong>管道的使用</strong>：通过一些常用的过滤程序，如 <code>grep</code>、<code>sort</code> 等，可以帮助用户熟练掌握管道的使用。</li>
</ol>
<h3 id="13-2-1-试用"><a href="#13-2-1-试用" class="headerlink" title="13.2.1. 试用"></a>13.2.1. 试用</h3><ul>
<li><p>查看文件和目录：<code>ls -al /etc</code></p>
</li>
<li><p><code>-al</code>：表示以<code>长格式</code>显示<code>所有、包括隐藏文件</code>的信息</p>
</li>
<li><p>查看文件和目录，并且一行一行地看：<code>ls -al /etc | less</code></p>
</li>
</ul>
<p><img src="/img/试用.png" alt="img"></p>
<p>此时通过按<code>Enter</code>来实现“一行一行地看”。</p>
<p>管道<code>|</code>将前一条命令(<code>ls</code>)的输出作为下一个命令<code>less</code>的输入，然后就可以一行一行地看</p>
<h3 id="13-2-2-cut-提取命令"><a href="#13-2-2-cut-提取命令" class="headerlink" title="13.2.2. cut 提取命令"></a>13.2.2. cut 提取命令</h3><p><code>cut</code>命令用于从文件的每一行中提取选定的部分</p>
<ul>
<li><strong>一般情况下格式：</strong><code>cut [选项] [提取范围等具体参数] [输入文件]</code></li>
</ul>
<ol>
<li><strong>字段提取</strong></li>
</ol>
<ul>
<li><code>cut</code>可以基于字符位置、字节位置、字段分隔符等方式提取文本中的特定部分</li>
</ul>
<p>例如：<code>cut -d &#39;:&#39; -f 1,3 /etc/passwd</code></p>
<ul>
<li><code>cut</code>：用于从文本行中提取选定部分的命令</li>
<li><code>-d</code>：<em>delimiter分隔符</em>，用于指定字段分隔符，<code>:</code>指定了分隔符为冒号</li>
<li><code>-f</code>：<em>field字段</em>，用于指定要提取的字段编号，<code>1,3</code>指定了提取第1个和第3个字段</li>
<li><code>/etc/passwd</code>：要进行处理的文件路径</li>
</ul>
<p>执行这条命令后，会输出 <code>/etc/passwd</code> 文件中每一行的用户名和用户 ID，两个字段之间以空格分隔。例如，如果文件中有一行内容为 “user2:x:1001:1001:User Two:/home/user2:/bin/bash”，那么执行该命令后会输出 “user2 1001”。</p>
<ol>
<li><strong>字符提取</strong></li>
</ol>
<ul>
<li>可以使用 <code>-c</code>选项提取指定的字符范围。例如，提取文件中每行的第 1 到 10 个字符。</li>
</ul>
<p>例如：<code>cut -c 1-5 file.txt</code>：从<code>file.txt</code>文件的每一行中提取第1到第5个字符。</p>
<p>例如：<code>cut /etc/passwd -c 5-</code>：从<code>/etc/passwd</code>中提取第五个之后的字符。</p>
<h3 id="13-2-3-grep-过滤搜索命令"><a href="#13-2-3-grep-过滤搜索命令" class="headerlink" title="13.2.3. grep 过滤搜索命令"></a>13.2.3. grep 过滤搜索命令</h3><p><code>grep</code>命令是一种强大的文本搜索工具，在文本中或<code>stdin</code>中查找匹配字符串</p>
<ul>
<li>基本用法: <code>grep [选项] 模式 [文件]</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export | grep &quot;.*yanlou$&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>export</code>会列出当前<code>shell</code>中所有环境变量及其值。</li>
<li><code>|</code>：将<code>export</code>的输出作为输入传递给下一个命令</li>
<li><code>grep &quot;.*yanlou$&quot;</code>：匹配任意字符零次或多次，然后以”<code>yanlou</code>“结尾的字符串，<code>$</code>表示一行的末尾。</li>
</ol>
<ul>
<li>这个命令会在<code>export</code>列出的环境变量中查找以”<code>yanlou</code>“结尾的变量条目</li>
</ul>
<h3 id="13-2-4-wc-统计命令"><a href="#13-2-4-wc-统计命令" class="headerlink" title="13.2.4. wc 统计命令"></a>13.2.4. wc 统计命令</h3><p><code>wc</code>(<em>word count</em>)命令用于统计文件中的行数、单词数和字节数等信息</p>
<ol>
<li>行数统计：例如<code>wc -l /etc/passwd</code></li>
</ol>
<ul>
<li><code>wc</code>可以统计文件中的行数。行数通常用于了解文件的大小或确定程序输出的长度。</li>
</ul>
<ol>
<li>单词数统计：例如<code>wc -w /etc/passwd</code></li>
</ol>
<ul>
<li>统计文件中的单词数量。单词通常由空格、制表符或换行符分隔。</li>
</ul>
<ol>
<li>字节数统计：例如<code>wc -c /etc/passwd</code></li>
</ol>
<ul>
<li><p>确定文件的大小，以字节为单位。这对于了解文件占用的存储空间很有用。</p>
</li>
<li><p><strong>注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于 2 个字节的，具体数目是由字符编码决定的。</strong></p>
</li>
</ul>
<ol>
<li>字符数统计：例如<code>wc -m /etc/passwd</code></li>
</ol>
<ul>
<li>一些版本的 <code>wc</code> 命令还可以统计文件中的字符数量，包括换行符和其他特殊字符。</li>
</ul>
<ul>
<li><p>结合管道：<code>ls -dl /etc/*/ | wc -l</code>，统计<code>/etc</code>下面所有目录数：</p>
</li>
<li><p><code>-d</code>选项表示只列出目录本身，而不列出目录中的内容。</p>
</li>
<li><code>-l</code>选项表示以长格式显示信息，包括权限、所有者、大小、修改时间等。</li>
</ul>
<p><img src="/img/统计命令.png" alt="img"></p>
<h3 id="13-2-5-sort-排序命令"><a href="#13-2-5-sort-排序命令" class="headerlink" title="13.2.5. sort 排序命令"></a>13.2.5. sort 排序命令</h3><p><code>sort</code>命令用于·将输入按照一定方式排序，然后再输出，它支持的排序有按字典排序，数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等</p>
<p>例如：<code>cat /etc/passwd |sort</code>：默认为字典排序</p>
<ul>
<li><code>cat /etc/passwd | sort -r</code>：默认为反转排序</li>
<li><code>cat /etc/passwd | sort -t&#39;:&#39; -k 3</code>：按照特定字段进行排序，如果要<strong>按照数字排序</strong>就要加上<code>-n</code>参数：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/passwd | <span class="built_in">sort</span> -t<span class="string">&#x27;:&#x27;</span> -k 3 -n</span><br></pre></td></tr></table></figure>
<p><code>-t&#39;:&#39;</code>：可以理解为<code>token</code>（分隔符），告诉 “<code>sort</code>” 命令以冒号作为分隔符来区分不同的部分</p>
<p><code>-k</code>：可以联想为”<code>key</code>关键的缩写”，<code>-k 3</code>指定按照第三个字段进行排序</p>
<p>按照字母的字典序进行比较。比如，“<code>user10</code>” 会排在 “<code>user2</code>” 前面，因为在字典序中，“<code>1</code>” 的 ASCII 码值小于 “<code>2</code>”。</p>
<p>如果第三个字段是纯数字，那么会严格按照数字的大小进行排序。</p>
<ul>
<li><strong>注意观察第二个冒号后的数字：</strong></li>
</ul>
<p><img src="/img/sort.png" alt="img"></p>
<h3 id="13-2-6-uniq-去重命令"><a href="#13-2-6-uniq-去重命令" class="headerlink" title="13.2.6. uniq 去重命令"></a>13.2.6. uniq 去重命令</h3><ul>
<li><code>uniq</code> 命令可以用于过滤或者输出重复行</li>
</ul>
<p><strong>去重：</strong>对于一个包含多行文本的文件，如果有连续的重复行，<code>uniq</code>可以将这些重复行<strong>合并为一行</strong>，只保留一个副本。</p>
<p><strong>统计重复次数：</strong><code>uniq</code>可以统计文件中每行的重复次数，例如使用<code>-c</code>选项可以在每行前面显示该行在文件中出现的次数</p>
<p><strong>简单去重：</strong><code>uniq file.txt</code>会对文件”<code>file.txt</code>“去重处理。只保留不重复的行，会删除连续的重复行</p>
<h4 id="组合去重示例-1-：过滤重复行"><a href="#组合去重示例-1-：过滤重复行" class="headerlink" title="组合去重示例 1 ：过滤重复行"></a>组合去重示例 1 ：过滤重复行</h4><p><strong>已知</strong><code>**history**</code><strong>命令的输出内容如下：</strong><img src="/img/uniq1.png" alt="img"></p>
<p><strong>接着输入</strong>：<code>history | cut -c 8- | cut -d &#39; &#39; -f 1 | uniq</code></p>
<ol>
<li><code>histort | cut -c 8-</code>：这一步会从每个命令的第<code>8</code>个字符开始剪切，剪切结果如下</li>
</ol>
<p><img src="/img/uniq2.png" alt="img"></p>
<ol>
<li><code>cut -d &#39;&#39; -f 1</code>：这一步按照空格作为分隔符</li>
</ol>
<p><img src="/img/uniq3.png" alt="img"></p>
<ul>
<li><code>-d &#39; &#39;</code>：指定分隔符为一个空格字符。<code>-d</code> 选项后面跟的字符是字段的分隔符。</li>
<li><code>-f 1</code>：选择第一个字段。<code>-f</code> 选项后面跟的数字表示要选择的字段编号。</li>
</ul>
<ol>
<li><code>uniq</code>：这一步会去除连续的重复行</li>
</ol>
<p><img src="/img/uniq4.png" alt="img"></p>
<p>只能去连续重复的行，不是全文去重，所以要达到预期效果，我们在此之前<strong>先进行排序</strong>：</p>
<p>命令<code>history | cut -c 8- | cut -d &#39; &#39; -f 1 | sort | uniq</code></p>
<h4 id="组合去重示例-2-：输出重复过的行（重复的只输出一个）及重复次数"><a href="#组合去重示例-2-：输出重复过的行（重复的只输出一个）及重复次数" class="headerlink" title="组合去重示例 2 ：输出重复过的行（重复的只输出一个）及重复次数"></a>组合去重示例 2 ：<strong>输出重复过的行（重复的只输出一个）及重复次数</strong></h4><p><strong>假设</strong><code>**history**</code><strong>输出结果如下：</strong></p>
<p><img src="/img/uniq5.png" alt="img"></p>
<p><strong>接着输入</strong>：<code>history | cut -c 8- | cut -d &#39; &#39; -f 1 | sort | uniq -dc</code></p>
<ol>
<li><code>history | cut -c 8-</code>：这一步会输出每行第八个字符后面的内容</li>
</ol>
<p><img src="/img/uniq6.png" alt="img"></p>
<ol>
<li><code>cut -d &#39; &#39; -f 1</code>：这一步会按照空格作为分隔符，然后选择每个行的第一个字段：</li>
</ol>
<p><img src="/img/uniq7.png" alt="img"></p>
<ol>
<li><code>sort</code>:对上一步的结果进行排序</li>
<li><code>uniq -dc</code>:去除重复行，并显示每个唯一行出现的次数</li>
</ol>
<ul>
<li><code>-d</code>：联想<code>**duplicate**</code>单词，只显示重复的行。</li>
<li><code>-c</code>：联想<code>count</code>单词，在每行前显示该行出现的次数。</li>
</ul>
<h4 id="轻松一下"><a href="#轻松一下" class="headerlink" title="轻松一下"></a>轻松一下</h4><p>使用以前介绍过的方法，安装<code>aview</code>和<code>imagemagick</code>，然后用<code>asciiview</code>命令显示图片，使用方法可以用 man 命令查看。</p>
<p>Linus 大神的照片地址 <a target="_blank" rel="noopener" href="https://labfile.oss.aliyuncs.com/courses/1/Linus.png">https://labfile.oss.aliyuncs.com/courses/1/Linus.png</a></p>
<p><img src="/img/uniq大神.png" alt="img"></p>
<p>执行以下命令安装工具包并下载图片：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install -y aview imagemagick</span><br><span class="line"></span><br><span class="line">wget https://labfile.oss-internal.aliyuncs.com/courses/1/Linus.png</span><br></pre></td></tr></table></figure>
<p>执行 <code>asciiview [图片文件名]</code> 即可打开图片：</p>
<p><img src="/img/uniq大神1.png" alt="img"></p>
<h1 id="14-简单的文本处理"><a href="#14-简单的文本处理" class="headerlink" title="14. 简单的文本处理"></a>14. 简单的文本处理</h1><h2 id="14-1-文本处理命令"><a href="#14-1-文本处理命令" class="headerlink" title="14.1. 文本处理命令"></a>14.1. 文本处理命令</h2><h3 id="14-1-1-tr-命令"><a href="#14-1-1-tr-命令" class="headerlink" title="14.1.1. tr 命令"></a>14.1.1. tr 命令</h3><ul>
<li><code>tr</code>命令可以用来删除一段文本信息中的某些文字，或者将其进行转换</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> [option]...SET1 [SET2]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>SET2</code>：如果存在，指定用于转换的目标字符集合。当执行转换操作时，<code>SET1</code>中的每个字符将被替换为<code>SET2</code>中相应位置的字符。</li>
</ul>
<p><strong>常用的选项有</strong></p>
<ul>
<li><code>-d</code>：<code>echo&#39;hello shiyanlou&#39; | tr -d &#39;olh&#39;</code></li>
</ul>
<p>删除 “<code>hello shiyanlou</code>“中所有的’<code>o</code>‘，’<code>l</code>‘，’<code>h</code>‘</p>
<ul>
<li><code>-s</code>：<code>echo &#39;hello&#39; | tr -s &#39;l&#39;</code></li>
</ul>
<p>将”<code>hello</code>“中的<code>ll</code>，去重为一个<code>l</code></p>
<ul>
<li><code>echo &#39;input some text here&#39; | tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code>：</li>
</ul>
<p>命令的意思是将输入中的所有小写字母转换为大写字母</p>
<h3 id="14-1-2-col-命令"><a href="#14-1-2-col-命令" class="headerlink" title="14.1.2. col 命令"></a>14.1.2. col 命令</h3><p><strong>使用方式：</strong><code>col [option]</code></p>
<ul>
<li><code>col</code>命令可以将<code>Tab</code>换成对等数量的空格键，或反转这个操作</li>
</ul>
<p>常用的选项有：</p>
<ul>
<li><code>-x</code>：将<code>Tab</code>转换为空格</li>
<li><code>-h</code>：将空格转换为<code>Tab</code>（默认选项）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 /etc/protocols 中的不可见字符，可以看到很多 ^I ，这其实就是 Tab 转义成可见字符的符号</span></span><br><span class="line"><span class="built_in">cat</span> -A /etc/protocols</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格，然后再使用 cat 查看，你发现 ^I 不见了</span></span><br><span class="line"><span class="built_in">cat</span> /etc/protocols | col -x | <span class="built_in">cat</span> -A</span><br></pre></td></tr></table></figure>
<p><img src="/img/文本.png" alt="img">🔜<img src="/img/文本2.png" alt="img"></p>
<h3 id="14-1-3-join-命令"><a href="#14-1-3-join-命令" class="headerlink" title="14.1.3. join 命令"></a>14.1.3. join 命令</h3><p><strong>使用方式：</strong><code>join [option]... file1 file2</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-t</code></td>
<td>指定分隔符，默认为空格</td>
</tr>
<tr>
<td><code>-i</code></td>
<td>忽略大小写的差异</td>
</tr>
<tr>
<td><code>-1</code></td>
<td>指明第一个文件要用哪个字段来对比，默认对比第一个字段</td>
</tr>
<tr>
<td><code>-2</code></td>
<td>指明第二个文件要用哪个字段来对比，默认对比第一个字段</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>创建并合并两个文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/shiiyanlou</span><br><span class="line"><span class="comment">#创建两个文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 hello&#x27;</span> &gt; file1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1 shiyanlou&#x27;</span> &gt; file2 </span><br><span class="line"><span class="comment">#合并两个文件</span></span><br><span class="line"><span class="built_in">join</span> file1 file2</span><br></pre></td></tr></table></figure>
<p><img src="/img/join.png" alt="img"></p>
<ul>
<li>将 <code>/etc/passwd</code> 与 <code>/etc/shadow</code> 两个文件合并，指定以’<code>:</code>‘作为分隔符：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo join -t&#x27;:&#x27; /etc/passwd /etc/shadow</span><br></pre></td></tr></table></figure>
<ul>
<li><code>/etc/passwd</code>：指定第一个要合并的文件是 <code>/etc/passwd</code>。这个文件包含了系统用户的账户信息。</li>
<li><code>/etc/shadow</code>：指定第二个要合并的文件是 <code>/etc/shadow</code>。这个文件包含了系统用户的安全信息，如密码的哈希值和密码过期信息。</li>
</ul>
<p>合并示例：</p>
<p><strong>/etc/passwd 示例内容：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>/etc/shadow 示例内容：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:$6$gEHZevem<span class="variable">$DuZdI5Wf5Z8WUW0Z4Z0VqQx5KG03YWV</span>:17447:0:99999:7::: </span><br><span class="line">daemon:*:17447:0:99999:7::: </span><br><span class="line">bin:*:17447:0:99999:7::: </span><br><span class="line">sys:*:17447:0:99999:7::: </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>如果我们执行以下命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo join -t&#x27;:&#x27; /etc/passwd /etc/shadow</span><br></pre></td></tr></table></figure>
<p><code>**join**</code> <strong>命令会将</strong> <code>**/etc/passwd**</code> <strong>文件和</strong> <code>**/etc/shadow**</code> <strong>文件中第一个字段（用户名）相同的行合并起来。合并的结果可能如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash:$6$gEHZevem<span class="variable">$DuZdI5Wf5Z8WUW0Z4Z0VqQx5KG03YWV</span>:17447:0:99999:7::: </span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin:*:17447:0:99999:7:::</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin:*:17447:0:99999:7:::</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin:*:17447:0:99999:7:::</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>将 <code>/etc/passwd</code> 与 <code>/etc/group</code> 两个文件合并，指定以’<code>:</code>‘作为分隔符，分别比对第 4 和第 3 个字段：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo join -t&#x27;:&#x27; -1 4 /etc/passwd -2 3 /etc/group</span><br></pre></td></tr></table></figure>
<ul>
<li><code>-t &#39;:&#39;</code>：指定字段分隔符为冒号（:）。默认情况下，<code>join</code>命令使用制表符（tab）作为字段分隔符，这里通过<code>-t</code>选项指定为冒号。</li>
<li><code>-1 4</code>：指定第一个文件（<code>/etc/passwd</code>）中用于比较的字段是第四个字段。在<code>/etc/passwd</code>文件中，字段通常由冒号分隔，第四个字段是用户的主要组ID。</li>
<li><code>-2 3</code>：指定第二个文件（<code>/etc/group</code>）中用于比较的字段是第三个字段。在<code>/etc/group</code>文件中，第三个字段是组ID。</li>
<li><code>/etc/group</code>：指定第二个要合并的文件是<code>/etc/group</code>。这个文件包含了系统组的信息。</li>
</ul>
<h3 id="14-1-4-paste-命令"><a href="#14-1-4-paste-命令" class="headerlink" title="14.1.4. paste 命令"></a>14.1.4. paste 命令</h3><ul>
<li><code>paste</code>这个命令与<code>join</code> 命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以<code>Tab</code>隔开。</li>
</ul>
<p><strong>使用方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paste [option] file...</span><br></pre></td></tr></table></figure>
<p><strong>常用的选项有：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>选项</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-d</code></td>
<td>指定合并的分隔符，默认为 Tab</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>不合并到一行，每个文件为一行</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello &gt; file1</span><br><span class="line"><span class="built_in">echo</span> shiyanlou &gt; file2</span><br><span class="line"><span class="built_in">echo</span> www.shiyanlou.com &gt; file3</span><br><span class="line"><span class="built_in">paste</span> -d <span class="string">&#x27;:&#x27;</span> file1 file2 file3 <span class="comment">#指定合并的分隔符为&quot;:&quot;</span></span><br><span class="line"><span class="built_in">paste</span> -s file1 file2 file3 <span class="comment">#不合并到一行，每个文件为一行</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/paste.png" alt="img"></p>
<p><img src="/img/paste1.png" alt="img"></p>
<h1 id="15-数据流重定向"><a href="#15-数据流重定向" class="headerlink" title="15. 数据流重定向"></a>15. 数据流重定向</h1><h2 id="15-1-数据流重定向"><a href="#15-1-数据流重定向" class="headerlink" title="15.1. 数据流重定向"></a>15.1. 数据流重定向</h2><h3 id="15-1-1-简单的重定向"><a href="#15-1-1-简单的重定向" class="headerlink" title="15.1.1. 简单的重定向"></a>15.1.1. 简单的重定向</h3><p>Linux 默认提供了三个特殊设备，用于终端的显示和输出，分别为 <code>stdin</code>（标准输入，对应于你在终端的输入），<code>stdout</code>（标准输出，对应于终端的输出），<code>stderr</code>（标准错误输出，对应于终端的输出）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>文件描述符</strong></th>
<th><strong>设备文件</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>/dev/stdin</code></td>
<td>标准输入</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>/dev/stdout</code></td>
<td>标准输出</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>/dev/stderr</code></td>
<td>标准错误</td>
</tr>
</tbody>
</table>
</div>
<p>文件描述符：文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。</p>
<ul>
<li>默认使用终端的标准输入作为命令的输入和标准输出作为命令的输出：<code>cat</code></li>
</ul>
<ul>
<li>将<code>cat</code>的连续输出（<code>heredoc</code>方式）重定向到一个文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> Documents</span><br><span class="line"><span class="built_in">cat</span> &gt; Documents/test.c &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    printf(&quot;hello world\n&quot;);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/paste1.png" alt="img"></p>
<ul>
<li>heredoc 是一种重定向输入的方法，它允许你将多行文本直接输入到命令中，而不是逐行输入。这种方式特别适用于需要将大量文本作为命令输入的情况。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; output.txt</span></span><br><span class="line"><span class="string">这是第一行文本。</span></span><br><span class="line"><span class="string">这是第二行文本。</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt; EOF</code>开始了一个<code>heredoc</code>块，<code>EOF</code>是结束标识符，所有在<code>EOF</code>之前的文本都会被写入到<code>output.txt</code>文件中。</p>
<ul>
<li>将一个文件作为命令的输入，标准输出作为命令的输出，通过这个命令显示刚刚输入进去的这个文件的内容：<code>cat Documnets/test.c</code></li>
</ul>
<p><img src="/img/数据重定向.png" alt="img"></p>
<ul>
<li>将<code>echo</code>命令的输出从默认的标准输出重定向到一个普通文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello shiyanlou&#x27;</span> &gt; redirect</span><br><span class="line"><span class="built_in">cat</span> redirect</span><br></pre></td></tr></table></figure>
<h3 id="15-1-2-标准错误重定向"><a href="#15-1-2-标准错误重定向" class="headerlink" title="15.1.2.  标准错误重定向"></a>15.1.2.  标准错误重定向</h3><p>除了重定向标准输出到文件，还有一种就是将标准错误重定向，标准输出和标准错误都被指向伪终端的屏幕显示，所以我们经常看到一个命令的输出通常同时包含了标准输出和标准错误的结果。</p>
<ul>
<li>使用cat 命令<strong>同时读取两个文件</strong>，其中一个存在，另一个不存在：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat Documents/test.c hello.c</span><br></pre></td></tr></table></figure>
<p><img src="/img/数据重定向2.png" alt="img"></p>
<p>可以看到除了正确输出了前一个文件的内容，还在末尾出现了一条错误信息</p>
<ul>
<li>下面我们将输出重定向到<strong>一个文件</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat Documents/test.c hello.c &gt; somefile</span><br></pre></td></tr></table></figure>
<p><img src="/img/数据重定向2.png" alt="img"></p>
<ul>
<li>可以发现仍显示出了那条错误，那么我们如何<strong>隐藏某些错误或警告</strong>呢？</li>
</ul>
<p>——需要用到文件描述符<code>cat Documents/test.c hello.c &gt;somefile 2&gt;&amp;1</code></p>
<p>(通过添加 <code>2&gt;&amp;1</code>，确保了所有的输出（无论是正常的还是错误的）都会被写入到指定的文件中。)</p>
<p><strong>具体过程是这样的</strong>：因为<code>Document/test.c</code>文件存在，会正常读取显示并重定向到<code>somefile</code>文件中，而<code>hello.c</code>文件不存在，原本会输出<code>No such file or directory</code>这个错误信息，但是由于<code>2&gt;&amp;1</code>的存在，会将<code>2</code>输出的错误信息<strong>重定向</strong>到标准输出的位置，也就是<code>somefile</code>文件，因此，错误信息也会被追加到<code>somefile</code>文件的末尾。</p>
<p>或者只用<code>bash</code>提供的特殊的重定向符号”<code>&amp;</code>“将标准错误和标准输出同时重定向到文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat Documents/test.c hello.c &amp;&gt;somefilehell</span><br></pre></td></tr></table></figure>
<h3 id="15-1-3-使用tee重定向到多个文件"><a href="#15-1-3-使用tee重定向到多个文件" class="headerlink" title="15.1.3. 使用tee重定向到多个文件"></a>15.1.3. 使用<code>tee</code>重定向到多个文件</h3><ul>
<li>如果<strong>除了</strong>需要将输出重定向文件，<strong>也</strong>需要将信息打印在终端，那么可以使用<code>tee</code>命令来实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#x27;hello shiyanlou&#x27; | tee hello</span><br></pre></td></tr></table></figure>
<h3 id="15-1-4-永久重定向"><a href="#15-1-4-永久重定向" class="headerlink" title="15.1.4.  永久重定向"></a>15.1.4.  永久重定向</h3><p>比如在一个脚本中，你需要某一部分的命令的输出全部进行重定向，<strong>难道要让你在每个命令上面加上临时重定向的操作吗</strong>，那如何做到永久有效呢？</p>
<p><strong>可以使用</strong><code>**exec**</code><strong>命令实现永久重定向</strong>，<code>exec</code>命令的作用是使用指定的命令替换当前的<code>Shell</code>，即使用一个进程替换当前进程，或者指定新的重定向。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先开启一个子 Shell</span></span><br><span class="line">zsh</span><br><span class="line"><span class="comment"># 使用exec替换当前进程的重定向，将标准输出重定向到一个文件</span></span><br><span class="line"><span class="built_in">exec</span> 1&gt;somefile</span><br><span class="line"><span class="comment"># 后面你执行的命令的输出都将被重定向到文件中，直到你退出当前子shell，或取消exec的重定向</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="built_in">cat</span> somefile</span><br></pre></td></tr></table></figure>
<p><img src="/img/标准重定向.png" alt="img"></p>
<h3 id="15-1-5-创建输出文件描述符"><a href="#15-1-5-创建输出文件描述符" class="headerlink" title="15.1.5.  创建输出文件描述符"></a>15.1.5.  创建输出文件描述符</h3><ul>
<li>在 Shell 中有 9 个文件描述符。上面我们使用了也是它默认提供的 0，1，2 号文件描述符。另外我们还可以使用 3-8 的文件描述符，只是它们默认没有打开而已。</li>
<li>查看当前 Shell 进程中打开的文件描述符：<code>cd /dev/fd/;ls -Al</code></li>
</ul>
<p><code>/dev/fd/</code> 是一个特殊的目录，称为文件描述符目录。在这个目录下，每个子目录都代表一个当前shell会话中打开的文件描述符。文件描述符是内核用来跟踪打开的文件、套接字、管道等的索引。例如，<code>/dev/fd/0</code> 通常代表标准输入（stdin），<code>/dev/fd/1</code> 代表标准输出（stdout），<code>/dev/fd/2</code> 代表标准错误输出（stderr）。</p>
<ul>
<li>创建文件描述符：<code>exec 3&gt;somefile</code>，将文件描述符3指向一个名为<code>somefile</code>的文件</li>
<li>通过文件描述符写入文件：<code>echo &quot;this is test&quot; &gt;&amp;3</code>：<code>&gt;&amp;3</code>将<code>echo</code>命令的输出重定向到文件描述符3指向的文件，也就是之前创建的<code>somefile</code></li>
</ul>
<h3 id="15-1-6-关闭文件描述符"><a href="#15-1-6-关闭文件描述符" class="headerlink" title="15.1.6. 关闭文件描述符"></a>15.1.6. 关闭文件描述符</h3><ul>
<li>刚刚创建了一个文件描述符3，现在可以使用<code>exec 3&gt;&amp;-</code>将文件描述符3关闭。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;-`：是一个特殊的引用，表示“使用前一个文件描述符”，这个命令的效果等同于直接关闭文件描述符`3</span><br></pre></td></tr></table></figure>
<h3 id="15-1-7-完全屏蔽”命令的输出”"><a href="#15-1-7-完全屏蔽”命令的输出”" class="headerlink" title="15.1.7. 完全屏蔽”命令的输出”"></a>15.1.7. 完全屏蔽”命令的输出”</h3><p>在Linux中，有一个被称为黑洞的设备文件，所有导入它的数据都将被吞噬。</p>
<ul>
<li>可以利用<code>/dev/null</code>屏蔽命令的输出：</li>
</ul>
<p><code>cat Documents/test.c 1&gt;/dev/null 2&gt;&amp;1</code>，这里将Document和/test.c文件的内容尝试输出出来，但将数据重定向到<code>/dev/null</code>将导致数据被丢弃，无法输出出来。</p>
<ul>
<li>将不会在终端上看到任何错误信息，因为错误信息也被重定向到了<code>/dev/null</code>。</li>
</ul>
<h3 id="15-1-8-使用xargs分割参数列表"><a href="#15-1-8-使用xargs分割参数列表" class="headerlink" title="15.1.8. 使用xargs分割参数列表"></a>15.1.8. 使用<code>xargs</code>分割参数列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut -d: -f1 &lt; /etc/passwd | sort | xargs echo</span><br></pre></td></tr></table></figure>
<ul>
<li>这条命令中，<code>xargs</code>将输入转换为命令行参数，这里的输入，指的是经过<code>sort</code>后输出的内容，</li>
</ul>
<p>而”转换成命令行参数”，意思是将<code>sort</code>输出的每一行，作为参数，传给<code>echo</code>命令，这样<code>echo</code>就能一个接一个输出出来、不用分行了：</p>
<ol>
<li>不加<code>xargs</code>参数的输出结果：</li>
</ol>
<p><img src="/img/重定向到.png" alt="img"></p>
<ol>
<li>加了<code>xargs</code>参数的输出结果：</li>
</ol>
<p><img src="/img/永久重定向.png" alt="img"></p>
<h1 id="16-挑战：历史命令"><a href="#16-挑战：历史命令" class="headerlink" title="16. 挑战：历史命令"></a>16. 挑战：历史命令</h1><ul>
<li><strong>介绍</strong></li>
</ul>
<p>在 Linux 中，对于文本的处理和分析是极为重要的，现在有一个文件叫做 data1，可以使用下面的命令下载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /home/shiyanlou</span><br><span class="line">wget https://labfile.oss-internal.aliyuncs.com/courses/1/data1</span><br></pre></td></tr></table></figure>
<p>data1 文件里记录是一些命令的操作记录，现在需要你从里面找出出现频率次数前 3 的命令并保存在 <code>/home/shiyanlou/result</code></p>
<ul>
<li><strong>目标</strong></li>
</ul>
<ol>
<li>处理文本文件 <code>/home/shiyanlou/data1</code></li>
<li>将结果写入 <code>/home/shiyanlou/result</code></li>
<li>结果包含三行内容，每行内容都是出现的次数和命令名称，如“100 ls”</li>
</ol>
<ul>
<li><strong>提示</strong></li>
</ul>
<ol>
<li>cut 截取 (参数可以使用 <code>-c 8-</code>，使用 man cut 可以查看含义)</li>
<li><code>uniq -dc</code> 去重</li>
<li>sort 的参数选择 <code>-k1 -n -r</code></li>
<li>操作过程使用管道，例如：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/shiyanlou</span><br><span class="line"><span class="built_in">cat</span> data1 |....|....|....   &gt;  /home/shiyanlou/result</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>参考答案</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> data1 |<span class="built_in">cut</span> -c 8-|<span class="built_in">sort</span>|<span class="built_in">uniq</span> -dc|<span class="built_in">sort</span> -rn -k1 |<span class="built_in">head</span> -3 &gt; /home/shiyanlou/result</span><br></pre></td></tr></table></figure>
<ol>
<li><code>cat data1</code><br><code>cat</code>命令用于连接文件并打印到标准输出。这里它读取<code>data1</code>文件的内容。</li>
<li><code>cut -c 8-</code><br><code>cut</code>命令用于剪切（提取）文件中的列或字符。</li>
</ol>
<ul>
<li><code>-c 8-</code>选项指定了要提取从第8个字符开始到行尾的所有字符。</li>
</ul>
<ol>
<li><code>sort</code><br><code>sort</code>命令对输入的文本进行排序。</li>
<li><code>uniq -dc</code><br><code>uniq</code>命令用于<strong>去除重复的行。</strong></li>
</ol>
<ul>
<li><code>-d</code>选项表示只显示重复的行。</li>
<li><code>-c</code>选项表示在显示重复行的同时，显示该行出现的次数。</li>
</ul>
<ol>
<li><code>sort -rn -k1</code><br>再次使用<code>sort</code>命令对<code>uniq</code>的输出进行排序。</li>
</ol>
<ul>
<li><code>-r</code>选项表示<strong>反向排序，即按数字从大到小排序。</strong></li>
<li><code>-n</code>选项表示按数值大小排序。</li>
<li><code>-k1</code>选项表示按照第一列排序。</li>
</ul>
<ol>
<li><code>head -3</code><br><code>head</code>命令用于输出文件的开头部分，默认情况下显示前10行。</li>
</ol>
<ul>
<li><code>**-3**</code><strong>选项指定显示前3行。</strong></li>
</ul>
<ol>
<li><code>&gt; /home/shiyanlou/result</code><br><code>&gt;</code>是重定向操作符，它将<strong>整个流水线的输出重定向到**</strong>指定的文件。**</li>
</ol>
<ul>
<li><code>/home/shiyanlou/result</code>是输出文件的路径。</li>
</ul>
<h1 id="17-正则表达式基础"><a href="#17-正则表达式基础" class="headerlink" title="17. 正则表达式基础"></a>17. 正则表达式基础</h1><p><strong>正则表达式</strong>，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。</p>
<ul>
<li>简单的说形式和功能上正则表达式和我们前面讲的通配符很像</li>
</ul>
<h2 id="17-1-举例"><a href="#17-1-举例" class="headerlink" title="17.1. 举例"></a>17.1. 举例</h2><p>假设我们这样一个文本文件，包含<code>shiyanlou</code>和<code>shilouyan</code>这两个字符串，同样一个表达式<code>shi*</code></p>
<p>将同时匹配这两个字符串，它可以匹配<code>shiyanlou</code>和<code>shilouyan</code>两个字符</p>
<h2 id="17-2-基本语法"><a href="#17-2-基本语法" class="headerlink" title="17.2. 基本语法"></a>17.2. 基本语法</h2><p>这部分参考笔记《正则表达式》</p>
<h2 id="17-3-grep-模式匹配命令"><a href="#17-3-grep-模式匹配命令" class="headerlink" title="17.3. grep 模式匹配命令"></a>17.3. grep 模式匹配命令</h2><ul>
<li><code>**grep**</code> 默认使用基本正则表达式。如果需要使用扩展正则表达式，可以使用 <code>-E</code> 选项</li>
</ul>
<h3 id="17-3-1-基本操作"><a href="#17-3-1-基本操作" class="headerlink" title="17.3.1. 基本操作"></a>17.3.1. 基本操作</h3><p><code>grep</code>命令用于<strong>打印输出文本中匹配的模式串</strong>，它使用正则表达式作为模式匹配的条件</p>
<ul>
<li><strong>基本用法：</strong><code>grep [选项] 模式 [文件]</code>，其中‘模式’是想要搜索的文本，‘文件’是要搜索的文件。</li>
<li><strong>常用参数【选项】：</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-b</code></td>
<td>将二进制文件作为文本来进行匹配</td>
</tr>
<tr>
<td><code>-c</code></td>
<td><code>--count</code>：只显示匹配行的数量，不显示行的内容</td>
</tr>
<tr>
<td><code>-i</code></td>
<td><code>--ignore-case</code>：忽略大小写</td>
</tr>
<tr>
<td><code>-n</code></td>
<td><code>--lineno</code>: 显示匹配行的行号</td>
</tr>
<tr>
<td><code>-v</code></td>
<td><code>--invert-match</code>：反选，显示不匹配的行</td>
</tr>
<tr>
<td><code>-r</code></td>
<td><code>--recursive</code>：递归地在所有文件中查找</td>
</tr>
<tr>
<td><code>-A n</code></td>
<td>n 为正整数，表示 after 的意思，除了列出匹配行之外，还列出后面的 n 行</td>
</tr>
<tr>
<td><code>-B n</code></td>
<td>n 为正整数，表示 before 的意思，除了列出匹配行之外，还列出前面的 n 行</td>
</tr>
<tr>
<td><code>--color=auto</code></td>
<td>将输出中的匹配项设置为自动颜色显示</td>
</tr>
</tbody>
</table>
</div>
<h3 id="17-3-2-使用正则表达式"><a href="#17-3-2-使用正则表达式" class="headerlink" title="17.3.2. 使用正则表达式"></a>17.3.2. 使用正则表达式</h3><p><strong>位置</strong></p>
<ul>
<li>查找 <code>/etc/group</code> 文件中以 <code>shiyanlou</code> 为开头的行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&#x27;^shiyanlou&#x27;</span> /etc/group</span><br></pre></td></tr></table></figure>
<p><strong>数量</strong></p>
<p><code>echo &#39;zero\nzo\nzoo&#39; | grep &#39;z.*o&#39;</code>匹配以’<code>z</code>‘开头，以’<code>o</code>‘结尾的所有字符串</p>
<p><code>echo &#39;zero\nzo\nzoo&#39; | grep &#39;z.o&#39;</code>匹配以’<code>z</code>‘开头，中间包含一个任意字符的字符串</p>
<p><code>echo &#39;zero\nzo\nzoo&#39; | grep &#39;zo*&#39;</code>匹配以’<code>z</code>‘开头，以任意多个’<code>o</code>’结尾的字符串</p>
<p><strong>选择</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grep默认是区分大小写的，这里将匹配所有的小写字母</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[a-z]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的数字</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[0-9]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的数字</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[[:digit:]]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的小写字母</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[[:lower:]]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的大写字母</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[[:upper:]]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的字母和数字，包括0-9，a-z，A-Z</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[[:alnum:]]&#x27;</span></span><br><span class="line"><span class="comment"># 将匹配所有的字母</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1234\nabcd&#x27;</span> | grep <span class="string">&#x27;[[:alpha:]]&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用扩展正则表达式，ERE</strong></p>
<p>要通过 <code>grep</code> 使用扩展正则表达式需要加上 <code>-E</code> 参数，或使用 <code>egrep</code>。</p>
<h2 id="17-4-sed流编辑器"><a href="#17-4-sed流编辑器" class="headerlink" title="17.4. sed流编辑器"></a>17.4. <code>sed</code>流编辑器</h2><p><strong>sed</strong>是<code>stream editor</code>的缩写，即流编辑器。用于对文本数据进行过滤和转换。</p>
<ul>
<li>它可以直接在命令行中运行，而不需要手动打开和编辑每个文件</li>
</ul>
<h3 id="17-4-1-sed-常用参数介绍"><a href="#17-4-1-sed-常用参数介绍" class="headerlink" title="17.4.1. sed 常用参数介绍"></a>17.4.1. sed 常用参数介绍</h3><h4 id="17-4-1-1-基本语法"><a href="#17-4-1-1-基本语法" class="headerlink" title="17.4.1.1. 基本语法"></a>17.4.1.1. 基本语法</h4><ol>
<li><code>sed [选项] &#39;命令&#39; 文件</code></li>
</ol>
<ul>
<li><strong>选项</strong>：如 <code>-i</code> 用于原地编辑。</li>
<li><strong>命令</strong>：<code>sed</code> 的操作命令，如 <code>s</code> 用于替换。</li>
<li><strong>文件</strong>：你要处理的文件。</li>
</ul>
<ol>
<li><code>sed [选项] -e &#39;命令1&#39; -e &#39;命令2&#39; -e &#39;命令3&#39; 文件</code>[<code>-e</code>用于在脚本中添加多个执行命令一次执行]</li>
</ol>
<ul>
<li><code>-n</code>：安静模式，只打印受影响的行，默认打印输入数据的全部内容</li>
<li><code>-i</code>：使用 <code>-i</code> 选项可以对文件进行原地编辑，即直接修改文件内容。</li>
<li><code>-r</code>：使用扩展正则表达式，默认为标准正则表达式</li>
</ul>
<h4 id="17-4-1-2-替换文本"><a href="#17-4-1-2-替换文本" class="headerlink" title="17.4.1.2. 替换文本"></a>17.4.1.2. 替换文本</h4><ol>
<li>查看文件内容</li>
</ol>
<p>在开始编辑之前，我们先看看文件的内容。假设我们有一个名为 <code>example.txt</code> 的文件，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello world</span><br><span class="line">This is a test</span><br><span class="line">Hello again</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>cat</code> 命令查看文件内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> example.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>**sed**</code> <strong>最常用的操作之一是替换文本。假设我们想将文件中的 “Hello” 替换为 “Hi”。</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/Hello/Hi/g&#x27;</span> example.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>s</code> 表示替换操作。</li>
<li><code>/Hello/</code> 是我们要查找的文本。</li>
<li><code>/Hi/</code> 是我们要替换成的文本。</li>
<li><code>g</code> 表示全局替换（替换行中所有匹配的文本）。</li>
</ul>
<p>这个命令会输出替换后的结果，但不会改变原始文件。如果你想直接修改文件，可以使用 <code>-i</code> 选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/Hello/Hi/g&#x27;</span> example.txt</span><br></pre></td></tr></table></figure>
<h4 id="17-4-1-3-删除文本"><a href="#17-4-1-3-删除文本" class="headerlink" title="17.4.1.3.  删除文本"></a>17.4.1.3.  删除文本</h4><p>如果你想删除包含特定文本的行，可以使用 <code>d</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/This/d&#x27;</span> example.txt</span><br></pre></td></tr></table></figure>
<p>这会删除所有包含 “This” 的行。</p>
<h4 id="17-4-1-4-插入和追加文本"><a href="#17-4-1-4-插入和追加文本" class="headerlink" title="17.4.1.4. 插入和追加文本"></a>17.4.1.4. 插入和追加文本</h4><p><strong>插入</strong> (<code>i</code>)：在匹配行之前插入文本。</p>
<p><strong>追加</strong> (<code>a</code>)：在匹配行之后追加文本。</p>
<p>例如，向文件的每一行前插入 “NEW: “：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;iNEW: &#x27;</span> example.txt</span><br></pre></td></tr></table></figure>
<p>向文件的每一行后追加 “ END”：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;aEND&#x27;</span> example.txt</span><br></pre></td></tr></table></figure>
<h4 id="17-4-1-5-打印特定行"><a href="#17-4-1-5-打印特定行" class="headerlink" title="17.4.1.5. 打印特定行"></a>17.4.1.5. 打印特定行</h4><p>如果你想打印文件的特定行，可以使用 <code>=</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;=&#x27;</span> example.txt</span><br></pre></td></tr></table></figure>
<p>这会打印每一行的行号。</p>
<h4 id="17-4-1-6-组合命令"><a href="#17-4-1-6-组合命令" class="headerlink" title="17.4.1.6. 组合命令"></a>17.4.1.6. 组合命令</h4><p>你可以使用 <code>-e</code> 选项组合多个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">&#x27;s/Hello/Hi/g&#x27;</span> -e <span class="string">&#x27;s/world/planet/g&#x27;</span> example.txt</span><br></pre></td></tr></table></figure>
<p>这会先替换 “Hello” 为 “Hi”，然后替换 “world” 为 “planet”。</p>
<h4 id="17-4-1-7-正则表达式"><a href="#17-4-1-7-正则表达式" class="headerlink" title="17.4.1.7. 正则表达式"></a>17.4.1.7. 正则表达式</h4><p><code>sed</code> 支持正则表达式，这使得它在文本处理上非常灵活。例如，替换所有以 “H” 开头的行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^H/Hi/&#x27;</span> example.txt</span><br></pre></td></tr></table></figure>
<p>这里的 <code>^</code> 是正则表达式，表示行的开始。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Leo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/10/29/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/">http://example.com/2024/10/29/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Leo's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/19/2024-11-19%E5%8F%8D%E6%80%9D%E8%A7%84%E5%88%92/" title="24.11.19阶段性反思"><img class="cover" src="/img/%E6%98%9F%E7%A9%BA%E5%9B%BE.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">24.11.19阶段性反思</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/30/24-9-30%E9%98%B6%E6%AE%B5%E6%80%A7%E5%8F%8D%E6%80%9D/" title="24.9.30阶段性反思"><img class="cover" src="/img/%E6%98%9F%E7%A9%BA%E5%9B%BE.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">24.9.30阶段性反思</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/websitelogo.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Leo</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">1. Linux系统简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Linux%E5%8E%86%E5%8F%B2%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. Linux历史简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Linux%E9%87%8D%E8%A6%81%E4%BA%BA%E7%89%A9"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. Linux重要人物</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Linux%E4%B8%8EWindows%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. Linux与Windows区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Linux%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.</span> <span class="toc-text">1.4. Linux学习路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">2. 基本概念及操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%BB%88%E7%AB%AF"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 终端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-shell"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 常用快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%BE%93%E5%87%BA%E5%9B%BE%E5%BD%A2%E5%91%BD%E4%BB%A4"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. 输出图形命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%94%A8%E6%88%B7%E5%8F%8A%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3. 用户及文件权限管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%9F%A5%E7%9C%8B%E7%94%A8%E6%88%B7"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 查看用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 创建用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 用户组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. 删除用户和用户组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">4.</span> <span class="toc-text">4. Linux文件权限</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 查看文件权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%8F%98%E6%9B%B4%E6%96%87%E4%BB%B6%E6%89%80%E6%9C%89%E8%80%85"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 变更文件所有者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 修改文件权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-adduser-%E5%92%8C-useradd-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. adduser 和 useradd 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E4%BD%9C%E4%B8%9A"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. 作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">5. Linux目录结构及文件基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-FHS%E6%A0%87%E5%87%86"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. FHS标准</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. 目录路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Linux%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. Linux文件的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E6%96%B0%E5%BB%BA"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1. 新建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-2-%E5%A4%8D%E5%88%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2. 复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-3-%E5%88%A0%E9%99%A4"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3. 删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-4-%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">5.3.4.</span> <span class="toc-text">5.3.4. 移动文件与文件重命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">5.3.5.</span> <span class="toc-text"> </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-5-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6"><span class="toc-number">5.3.6.</span> <span class="toc-text">5.3.5. 查看文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-6-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.7.</span> <span class="toc-text">5.3.6. 查看文件类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-7-%E7%BC%96%E8%BE%91%E6%96%87%E4%BB%B6"><span class="toc-number">5.3.8.</span> <span class="toc-text">5.3.7. 编辑文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%9B%B4%E5%A4%9A"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. 更多</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E4%BD%9C%E4%B8%9A"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. 作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE"><span class="toc-number">6.</span> <span class="toc-text">6. 环境变量与文件查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%91%BD%E4%BB%A4%E7%9A%84%E6%9F%A5%E6%89%BE%E8%B7%AF%E5%BE%84%E4%B8%8E%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 命令的查找路径与顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E5%BE%84%E5%88%B0%E2%80%9DPATH%E2%80%9D%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. 添加自定义路径到”PATH”环境变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4%E5%B7%B2%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. 修改和删除已有变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%A6%82%E4%BD%95%E8%AE%A9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88"><span class="toc-number">6.5.</span> <span class="toc-text">6.5. 如何让环境变量立即生效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="toc-number">6.6.</span> <span class="toc-text">6.6. 搜索文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E6%9B%B4%E5%A4%9A"><span class="toc-number">6.7.</span> <span class="toc-text">6.7. 更多</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E4%BD%9C%E4%B8%9A"><span class="toc-number">6.8.</span> <span class="toc-text">6.8. 作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%8C%91%E6%88%98%EF%BC%9A%E5%AF%BB%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-number">7.</span> <span class="toc-text">7. 挑战：寻找文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8E%E8%A7%A3%E5%8E%8B%E7%BC%A9"><span class="toc-number">8.</span> <span class="toc-text">8. 文件打包与解压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%B8%B8%E8%A7%81%E5%8E%8B%E7%BC%A9%E5%8C%85%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">8.1. 常见压缩包格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E6%89%93%E5%8C%85%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A7%A3%E5%8E%8B%E7%BC%A9"><span class="toc-number">8.2.</span> <span class="toc-text">8.2. 打包压缩和解压缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-zip%E5%8E%8B%E7%BC%A9%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.1. zip压缩打包程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E4%BD%BF%E7%94%A8unzip%E5%91%BD%E4%BB%A4%E8%A7%A3%E5%8E%8B%E7%BC%A9zip%E6%96%87%E4%BB%B6"><span class="toc-number">8.2.2.</span> <span class="toc-text">8.2.2. 使用unzip命令解压缩zip文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-tar%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7"><span class="toc-number">8.3.</span> <span class="toc-text">8.3. tar打包工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-tar-%E5%8C%85"><span class="toc-number">8.3.1.</span> <span class="toc-text">8.3.1. 创建一个 tar 包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-%E8%A7%A3%E5%8C%85%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%EF%BC%88-c%EF%BC%89"><span class="toc-number">8.3.2.</span> <span class="toc-text">8.3.2. 解包一个文件到指定目录（-c）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-%E5%8F%AA%E6%9F%A5%E7%9C%8B%E3%80%81%E4%B8%8D%E8%A7%A3%E5%8C%85%E6%96%87%E4%BB%B6"><span class="toc-number">8.3.3.</span> <span class="toc-text">8.3.3. 只查看、不解包文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4-%E4%BF%9D%E7%95%99%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E8%B7%9F%E9%9A%8F%E9%93%BE%E6%8E%A5"><span class="toc-number">8.3.4.</span> <span class="toc-text">8.3.4. 保留文件属性和跟随链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-5-%E5%B0%86-tar-%E4%B8%8E-gzip-%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">8.3.5.</span> <span class="toc-text">8.3.5. 将 tar 与 gzip 结合使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E6%80%BB%E7%BB%93"><span class="toc-number">8.4.</span> <span class="toc-text">8.4. 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E4%BD%9C%E4%B8%9A"><span class="toc-number">8.5.</span> <span class="toc-text">8.5. 作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">9. 文件系统操作与磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">9.1.</span> <span class="toc-text">9.1. 基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-1-%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%92%8C%E7%9B%AE%E5%BD%95%E5%AE%B9%E9%87%8F"><span class="toc-number">9.1.1.</span> <span class="toc-text">9.1.1. 查看磁盘和目录容量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E7%AE%80%E5%8D%95%E7%9A%84%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">9.2. 简单的磁盘管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%A3%81%E7%9B%98"><span class="toc-number">9.2.1.</span> <span class="toc-text">9.2.1. 创建虚拟磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-%E4%BD%BF%E7%94%A8dd%E5%91%BD%E4%BB%A4%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-number">9.2.2.</span> <span class="toc-text">9.2.2. 使用dd命令创建虚拟镜像文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-%E4%BD%BF%E7%94%A8mkfs%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%A3%81%E7%9B%98"><span class="toc-number">9.2.3.</span> <span class="toc-text">9.2.3. 使用mkfs命令格式化磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-4-%E4%BD%BF%E7%94%A8mount%E5%91%BD%E4%BB%A4%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98%E5%88%B0%E7%9B%AE%E5%BD%95%E6%A0%91"><span class="toc-number">9.2.4.</span> <span class="toc-text">9.2.4. 使用mount命令挂载磁盘到目录树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-5-%E4%BD%BF%E7%94%A8umount%E5%91%BD%E4%BB%A4%E5%8D%B8%E8%BD%BD%E5%B7%B2%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98"><span class="toc-number">9.2.5.</span> <span class="toc-text">9.2.5. 使用umount命令卸载已挂载磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-6-%E4%BD%BF%E7%94%A8fdisk%E4%B8%BA%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA"><span class="toc-number">9.2.6.</span> <span class="toc-text">9.2.6. 使用fdisk为磁盘分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-7-%E4%BD%BF%E7%94%A8loseup%E5%91%BD%E4%BB%A4%E5%BB%BA%E7%AB%8B%E9%95%9C%E5%83%8F%E4%B8%8E%E5%9B%9E%E7%8E%AF%E8%AE%BE%E5%A4%87%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">9.2.7.</span> <span class="toc-text">9.2.7. 使用loseup命令建立镜像与回环设备的关联</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E4%BD%9C%E4%B8%9A"><span class="toc-number">9.3.</span> <span class="toc-text">9.3. 作业</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Linux%E4%B8%8B%E7%9A%84%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4"><span class="toc-number">10.</span> <span class="toc-text">10. Linux下的帮助命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E5%86%85%E5%BB%BA%E5%91%BD%E4%BB%A4%E4%B8%8E%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">10.1.</span> <span class="toc-text">10.1. 内建命令与外部命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.2.</span> <span class="toc-text">10.2. 帮助命令的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-help-%E5%91%BD%E4%BB%A4"><span class="toc-number">10.2.1.</span> <span class="toc-text">10.2.1. help 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-2-man-%E5%91%BD%E4%BB%A4"><span class="toc-number">10.2.2.</span> <span class="toc-text">10.2.2. man 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-3-info-%E5%91%BD%E4%BB%A4"><span class="toc-number">10.2.3.</span> <span class="toc-text">10.2.3. info 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Linux-%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92-crontab"><span class="toc-number">11.</span> <span class="toc-text">11. Linux 任务计划 crontab</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-crontab-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.1.</span> <span class="toc-text">11.1. crontab 的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-1-crontab-%E7%AE%80%E4%BB%8B"><span class="toc-number">11.1.1.</span> <span class="toc-text">11.1.1. crontab 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-2-crontab-%E5%87%86%E5%A4%87"><span class="toc-number">11.1.2.</span> <span class="toc-text">11.1.2. crontab 准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-3-crontab-%E4%BD%BF%E7%94%A8"><span class="toc-number">11.1.3.</span> <span class="toc-text">11.1.3. crontab 使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-crontab-%E7%9A%84%E6%B7%B1%E5%85%A5"><span class="toc-number">11.2.</span> <span class="toc-text">11.2. crontab 的深入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E6%8C%91%E6%88%98%EF%BC%9A%E5%A4%87%E4%BB%BD%E6%97%A5%E5%BF%97"><span class="toc-number">12.</span> <span class="toc-text">12. 挑战：备份日志</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E7%AE%A1%E9%81%93"><span class="toc-number">13.</span> <span class="toc-text">13. 命令执行顺序控制与管道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">13.1.</span> <span class="toc-text">13.1. 命令执行顺序的控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-1-%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4"><span class="toc-number">13.1.1.</span> <span class="toc-text">13.1.1. 顺序执行多条命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-2-%E6%9C%89%E9%80%89%E6%8B%A9%E7%9A%84%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4"><span class="toc-number">13.1.2.</span> <span class="toc-text">13.1.2. 有选择的执行命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E7%AE%A1%E9%81%93"><span class="toc-number">13.2.</span> <span class="toc-text">13.2. 管道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-1-%E8%AF%95%E7%94%A8"><span class="toc-number">13.2.1.</span> <span class="toc-text">13.2.1. 试用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-2-cut-%E6%8F%90%E5%8F%96%E5%91%BD%E4%BB%A4"><span class="toc-number">13.2.2.</span> <span class="toc-text">13.2.2. cut 提取命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-3-grep-%E8%BF%87%E6%BB%A4%E6%90%9C%E7%B4%A2%E5%91%BD%E4%BB%A4"><span class="toc-number">13.2.3.</span> <span class="toc-text">13.2.3. grep 过滤搜索命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-4-wc-%E7%BB%9F%E8%AE%A1%E5%91%BD%E4%BB%A4"><span class="toc-number">13.2.4.</span> <span class="toc-text">13.2.4. wc 统计命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-5-sort-%E6%8E%92%E5%BA%8F%E5%91%BD%E4%BB%A4"><span class="toc-number">13.2.5.</span> <span class="toc-text">13.2.5. sort 排序命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-6-uniq-%E5%8E%BB%E9%87%8D%E5%91%BD%E4%BB%A4"><span class="toc-number">13.2.6.</span> <span class="toc-text">13.2.6. uniq 去重命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%8E%BB%E9%87%8D%E7%A4%BA%E4%BE%8B-1-%EF%BC%9A%E8%BF%87%E6%BB%A4%E9%87%8D%E5%A4%8D%E8%A1%8C"><span class="toc-number">13.2.6.1.</span> <span class="toc-text">组合去重示例 1 ：过滤重复行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%8E%BB%E9%87%8D%E7%A4%BA%E4%BE%8B-2-%EF%BC%9A%E8%BE%93%E5%87%BA%E9%87%8D%E5%A4%8D%E8%BF%87%E7%9A%84%E8%A1%8C%EF%BC%88%E9%87%8D%E5%A4%8D%E7%9A%84%E5%8F%AA%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%EF%BC%89%E5%8F%8A%E9%87%8D%E5%A4%8D%E6%AC%A1%E6%95%B0"><span class="toc-number">13.2.6.2.</span> <span class="toc-text">组合去重示例 2 ：输出重复过的行（重复的只输出一个）及重复次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E6%9D%BE%E4%B8%80%E4%B8%8B"><span class="toc-number">13.2.6.3.</span> <span class="toc-text">轻松一下</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">14. 简单的文本处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-number">14.1.</span> <span class="toc-text">14.1. 文本处理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-1-tr-%E5%91%BD%E4%BB%A4"><span class="toc-number">14.1.1.</span> <span class="toc-text">14.1.1. tr 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-2-col-%E5%91%BD%E4%BB%A4"><span class="toc-number">14.1.2.</span> <span class="toc-text">14.1.2. col 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-3-join-%E5%91%BD%E4%BB%A4"><span class="toc-number">14.1.3.</span> <span class="toc-text">14.1.3. join 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-4-paste-%E5%91%BD%E4%BB%A4"><span class="toc-number">14.1.4.</span> <span class="toc-text">14.1.4. paste 命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">15.</span> <span class="toc-text">15. 数据流重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">15.1.</span> <span class="toc-text">15.1. 数据流重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-1-%E7%AE%80%E5%8D%95%E7%9A%84%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">15.1.1.</span> <span class="toc-text">15.1.1. 简单的重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-2-%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">15.1.2.</span> <span class="toc-text">15.1.2.  标准错误重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-3-%E4%BD%BF%E7%94%A8tee%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">15.1.3.</span> <span class="toc-text">15.1.3. 使用tee重定向到多个文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-4-%E6%B0%B8%E4%B9%85%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">15.1.4.</span> <span class="toc-text">15.1.4.  永久重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-5-%E5%88%9B%E5%BB%BA%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">15.1.5.</span> <span class="toc-text">15.1.5.  创建输出文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-6-%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">15.1.6.</span> <span class="toc-text">15.1.6. 关闭文件描述符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-7-%E5%AE%8C%E5%85%A8%E5%B1%8F%E8%94%BD%E2%80%9D%E5%91%BD%E4%BB%A4%E7%9A%84%E8%BE%93%E5%87%BA%E2%80%9D"><span class="toc-number">15.1.7.</span> <span class="toc-text">15.1.7. 完全屏蔽”命令的输出”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-8-%E4%BD%BF%E7%94%A8xargs%E5%88%86%E5%89%B2%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">15.1.8.</span> <span class="toc-text">15.1.8. 使用xargs分割参数列表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E6%8C%91%E6%88%98%EF%BC%9A%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4"><span class="toc-number">16.</span> <span class="toc-text">16. 挑战：历史命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80"><span class="toc-number">17.</span> <span class="toc-text">17. 正则表达式基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-%E4%B8%BE%E4%BE%8B"><span class="toc-number">17.1.</span> <span class="toc-text">17.1. 举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">17.2.</span> <span class="toc-text">17.2. 基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-grep-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%91%BD%E4%BB%A4"><span class="toc-number">17.3.</span> <span class="toc-text">17.3. grep 模式匹配命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-1-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">17.3.1.</span> <span class="toc-text">17.3.1. 基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-3-2-%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">17.3.2.</span> <span class="toc-text">17.3.2. 使用正则表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-4-sed%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8"><span class="toc-number">17.4.</span> <span class="toc-text">17.4. sed流编辑器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#17-4-1-sed-%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">17.4.1.</span> <span class="toc-text">17.4.1. sed 常用参数介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-1-1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">17.4.1.1.</span> <span class="toc-text">17.4.1.1. 基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-1-2-%E6%9B%BF%E6%8D%A2%E6%96%87%E6%9C%AC"><span class="toc-number">17.4.1.2.</span> <span class="toc-text">17.4.1.2. 替换文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-1-3-%E5%88%A0%E9%99%A4%E6%96%87%E6%9C%AC"><span class="toc-number">17.4.1.3.</span> <span class="toc-text">17.4.1.3.  删除文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-1-4-%E6%8F%92%E5%85%A5%E5%92%8C%E8%BF%BD%E5%8A%A0%E6%96%87%E6%9C%AC"><span class="toc-number">17.4.1.4.</span> <span class="toc-text">17.4.1.4. 插入和追加文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-1-5-%E6%89%93%E5%8D%B0%E7%89%B9%E5%AE%9A%E8%A1%8C"><span class="toc-number">17.4.1.5.</span> <span class="toc-text">17.4.1.5. 打印特定行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-1-6-%E7%BB%84%E5%90%88%E5%91%BD%E4%BB%A4"><span class="toc-number">17.4.1.6.</span> <span class="toc-text">17.4.1.6. 组合命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-4-1-7-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">17.4.1.7.</span> <span class="toc-text">17.4.1.7. 正则表达式</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/05/Prompt%E7%9A%84%E9%81%93%E5%92%8C%E6%9C%AF/" title="Prompt的道和术"><img src="/img/AIlearning.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Prompt的道和术"/></a><div class="content"><a class="title" href="/2024/12/05/Prompt%E7%9A%84%E9%81%93%E5%92%8C%E6%9C%AF/" title="Prompt的道和术">Prompt的道和术</a><time datetime="2024-12-05T12:22:21.000Z" title="发表于 2024-12-05 20:22:21">2024-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/26/Anki%E5%88%B6%E5%8D%A1%E6%97%B6%E5%8F%82%E8%80%83%E8%AE%BE%E9%97%AE%E8%A7%92%E5%BA%A6/" title="Anki制卡时参考设问角度"><img src="/img/%E6%98%9F%E7%A9%BA%E5%9B%BE.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Anki制卡时参考设问角度"/></a><div class="content"><a class="title" href="/2024/11/26/Anki%E5%88%B6%E5%8D%A1%E6%97%B6%E5%8F%82%E8%80%83%E8%AE%BE%E9%97%AE%E8%A7%92%E5%BA%A6/" title="Anki制卡时参考设问角度">Anki制卡时参考设问角度</a><time datetime="2024-11-26T09:23:41.000Z" title="发表于 2024-11-26 17:23:41">2024-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/21/Anki%E6%9E%84%E5%BB%BA%E8%A7%84%E5%88%99%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5/" title="Anki构建规则及程序员的使用策略"><img src="/img/%E6%98%9F%E7%A9%BA%E5%9B%BE.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Anki构建规则及程序员的使用策略"/></a><div class="content"><a class="title" href="/2024/11/21/Anki%E6%9E%84%E5%BB%BA%E8%A7%84%E5%88%99%E5%8F%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AD%96%E7%95%A5/" title="Anki构建规则及程序员的使用策略">Anki构建规则及程序员的使用策略</a><time datetime="2024-11-21T09:06:26.000Z" title="发表于 2024-11-21 17:06:26">2024-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/20/Anki%E5%8D%A1%E7%89%87%E5%88%B6%E4%BD%9C%E6%8A%80%E5%B7%A7/" title="Anki卡片制作技巧"><img src="/img/%E6%98%9F%E7%A9%BA%E5%9B%BE.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Anki卡片制作技巧"/></a><div class="content"><a class="title" href="/2024/11/20/Anki%E5%8D%A1%E7%89%87%E5%88%B6%E4%BD%9C%E6%8A%80%E5%B7%A7/" title="Anki卡片制作技巧">Anki卡片制作技巧</a><time datetime="2024-11-20T11:23:41.000Z" title="发表于 2024-11-20 19:23:41">2024-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/19/2024-11-19%E5%8F%8D%E6%80%9D%E8%A7%84%E5%88%92/" title="24.11.19阶段性反思"><img src="/img/%E6%98%9F%E7%A9%BA%E5%9B%BE.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="24.11.19阶段性反思"/></a><div class="content"><a class="title" href="/2024/11/19/2024-11-19%E5%8F%8D%E6%80%9D%E8%A7%84%E5%88%92/" title="24.11.19阶段性反思">24.11.19阶段性反思</a><time datetime="2024-11-19T04:11:48.000Z" title="发表于 2024-11-19 12:11:48">2024-11-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Leo</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>